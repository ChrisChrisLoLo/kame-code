{"ast":null,"code":"import { ReturnSignal } from \"./interpreter\";\nimport { Environment } from \"./environment\";\nexport class Callable {}\nexport class LoxFunction extends Callable {\n  constructor(declaration, closure) {\n    super();\n    this.declaration = declaration;\n    this.closure = closure;\n  }\n\n  getArity() {\n    return this.declaration.params.length;\n  }\n\n  call(interpreter, args) {\n    const environment = new Environment(this.closure);\n    this.declaration.params.forEach((token, index) => {\n      environment.define(token, args[index]);\n    });\n\n    try {\n      interpreter.execBlock(this.declaration.body, environment);\n    } catch (error) {\n      if (error instanceof ReturnSignal) {\n        return error.value;\n      }\n\n      throw error;\n    }\n\n    return null;\n  }\n\n  toString() {\n    return `<fn ${this.declaration.name.lexeme}(${this.declaration.params.map(p => p.lexeme).join(\", \")})>`;\n  }\n\n}","map":{"version":3,"sources":["/home/chriz/Documents/kame-code/src/logic/tslox/callable.ts"],"names":["ReturnSignal","Environment","Callable","LoxFunction","constructor","declaration","closure","getArity","params","length","call","interpreter","args","environment","forEach","token","index","define","execBlock","body","error","value","toString","name","lexeme","map","p","join"],"mappings":"AACA,SAAgCA,YAAhC,QAAoD,eAApD;AACA,SAASC,WAAT,QAA4B,eAA5B;AAEA,OAAO,MAAeC,QAAf,CAAwB;AAM/B,OAAO,MAAMC,WAAN,SAA0BD,QAA1B,CAAmC;AACxCE,EAAAA,WAAW,CACAC,WADA,EAEAC,OAFA,EAGT;AACA;AADA,SAFSD,WAET,GAFSA,WAET;AAAA,SADSC,OACT,GADSA,OACT;AAED;;AAEDC,EAAAA,QAAQ,GAAG;AACT,WAAO,KAAKF,WAAL,CAAiBG,MAAjB,CAAwBC,MAA/B;AACD;;AAEDC,EAAAA,IAAI,CAACC,WAAD,EAA2BC,IAA3B,EAAuD;AACzD,UAAMC,WAAW,GAAG,IAAIZ,WAAJ,CAAgB,KAAKK,OAArB,CAApB;AAEA,SAAKD,WAAL,CAAiBG,MAAjB,CAAwBM,OAAxB,CAAgC,CAACC,KAAD,EAAQC,KAAR,KAAkB;AAChDH,MAAAA,WAAW,CAACI,MAAZ,CAAmBF,KAAnB,EAA0BH,IAAI,CAACI,KAAD,CAA9B;AACD,KAFD;;AAIA,QAAI;AACFL,MAAAA,WAAW,CAACO,SAAZ,CAAsB,KAAKb,WAAL,CAAiBc,IAAvC,EAA6CN,WAA7C;AACD,KAFD,CAEE,OAAOO,KAAP,EAAc;AACd,UAAIA,KAAK,YAAYpB,YAArB,EAAmC;AACjC,eAAOoB,KAAK,CAACC,KAAb;AACD;;AAED,YAAMD,KAAN;AACD;;AAED,WAAO,IAAP;AACD;;AAEDE,EAAAA,QAAQ,GAAG;AACT,WAAQ,OAAM,KAAKjB,WAAL,CAAiBkB,IAAjB,CAAsBC,MAAO,IAAG,KAAKnB,WAAL,CAAiBG,MAAjB,CAC3CiB,GAD2C,CACvCC,CAAC,IAAIA,CAAC,CAACF,MADgC,EAE3CG,IAF2C,CAEtC,IAFsC,CAEhC,IAFd;AAGD;;AApCuC","sourcesContent":["import * as Stmt from \"./stmt\"\nimport { Interpreter, LoxValue, ReturnSignal } from \"./interpreter\"\nimport { Environment } from \"./environment\"\n\nexport abstract class Callable {\n  abstract getArity(): number\n\n  abstract call(interpreter: Interpreter, args: LoxValue[]): LoxValue\n}\n\nexport class LoxFunction extends Callable {\n  constructor(\n    readonly declaration: Stmt.Function,\n    readonly closure: Environment\n  ) {\n    super()\n  }\n\n  getArity() {\n    return this.declaration.params.length\n  }\n\n  call(interpreter: Interpreter, args: LoxValue[]): LoxValue {\n    const environment = new Environment(this.closure)\n\n    this.declaration.params.forEach((token, index) => {\n      environment.define(token, args[index])\n    })\n\n    try {\n      interpreter.execBlock(this.declaration.body, environment)\n    } catch (error) {\n      if (error instanceof ReturnSignal) {\n        return error.value\n      }\n\n      throw error\n    }\n\n    return null\n  }\n\n  toString() {\n    return `<fn ${this.declaration.name.lexeme}(${this.declaration.params\n      .map(p => p.lexeme)\n      .join(\", \")})>`\n  }\n}\n"]},"metadata":{},"sourceType":"module"}