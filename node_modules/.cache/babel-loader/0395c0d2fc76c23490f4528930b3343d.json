{"ast":null,"code":"// Generated code\nexport class Binary {\n  constructor(left, operator, right) {\n    this.left = left;\n    this.operator = operator;\n    this.right = right;\n  }\n\n  accept(visitor) {\n    return visitor.visitBinaryExpr(this);\n  }\n\n}\nexport class Logical {\n  constructor(left, operator, right) {\n    this.left = left;\n    this.operator = operator;\n    this.right = right;\n  }\n\n  accept(visitor) {\n    return visitor.visitLogicalExpr(this);\n  }\n\n}\nexport class Ternary {\n  constructor(condition, left, right) {\n    this.condition = condition;\n    this.left = left;\n    this.right = right;\n  }\n\n  accept(visitor) {\n    return visitor.visitTernaryExpr(this);\n  }\n\n}\nexport class Grouping {\n  constructor(expression) {\n    this.expression = expression;\n  }\n\n  accept(visitor) {\n    return visitor.visitGroupingExpr(this);\n  }\n\n}\nexport class Literal {\n  constructor(value) {\n    this.value = value;\n  }\n\n  accept(visitor) {\n    return visitor.visitLiteralExpr(this);\n  }\n\n}\nexport class Unary {\n  constructor(operator, right) {\n    this.operator = operator;\n    this.right = right;\n  }\n\n  accept(visitor) {\n    return visitor.visitUnaryExpr(this);\n  }\n\n}\nexport class Variable {\n  constructor(name) {\n    this.name = name;\n  }\n\n  accept(visitor) {\n    return visitor.visitVariableExpr(this);\n  }\n\n}\nexport class Assign {\n  constructor(variable, value) {\n    this.variable = variable;\n    this.value = value;\n  }\n\n  accept(visitor) {\n    return visitor.visitAssignExpr(this);\n  }\n\n}\nexport class Call {\n  constructor(callee, paren, args) {\n    this.callee = callee;\n    this.paren = paren;\n    this.args = args;\n  }\n\n  accept(visitor) {\n    return visitor.visitCallExpr(this);\n  }\n\n}","map":{"version":3,"sources":["/home/chriz/Documents/kame-code/src/logic/tslox/expr.ts"],"names":["Binary","constructor","left","operator","right","accept","visitor","visitBinaryExpr","Logical","visitLogicalExpr","Ternary","condition","visitTernaryExpr","Grouping","expression","visitGroupingExpr","Literal","value","visitLiteralExpr","Unary","visitUnaryExpr","Variable","name","visitVariableExpr","Assign","variable","visitAssignExpr","Call","callee","paren","args","visitCallExpr"],"mappings":"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","sourcesContent":["// Generated code\n\nimport { Token, Literal as LiteralValue } from \"./token\"\n\nexport interface Visitor<T> {\n  visitBinaryExpr(expr: Binary): T\n  visitLogicalExpr(expr: Logical): T\n  visitTernaryExpr(expr: Ternary): T\n  visitGroupingExpr(expr: Grouping): T\n  visitLiteralExpr(expr: Literal): T\n  visitUnaryExpr(expr: Unary): T\n  visitVariableExpr(expr: Variable): T\n  visitAssignExpr(expr: Assign): T\n  visitCallExpr(expr: Call): T\n}\n\nexport interface Expr {\n  accept<T>(visitor: Visitor<T>): T\n}\n\nexport class Binary implements Expr {\n  constructor(\n    readonly left: Expr,\n    readonly operator: Token,\n    readonly right: Expr\n  ) {}\n\n  accept<T>(visitor: Visitor<T>): T {\n    return visitor.visitBinaryExpr(this)\n  }\n}\n\nexport class Logical implements Expr {\n  constructor(\n    readonly left: Expr,\n    readonly operator: Token,\n    readonly right: Expr\n  ) {}\n\n  accept<T>(visitor: Visitor<T>): T {\n    return visitor.visitLogicalExpr(this)\n  }\n}\n\nexport class Ternary implements Expr {\n  constructor(\n    readonly condition: Expr,\n    readonly left: Expr,\n    readonly right: Expr\n  ) {}\n\n  accept<T>(visitor: Visitor<T>): T {\n    return visitor.visitTernaryExpr(this)\n  }\n}\n\nexport class Grouping implements Expr {\n  constructor(readonly expression: Expr) {}\n\n  accept<T>(visitor: Visitor<T>): T {\n    return visitor.visitGroupingExpr(this)\n  }\n}\n\nexport class Literal implements Expr {\n  constructor(readonly value: LiteralValue) {}\n\n  accept<T>(visitor: Visitor<T>): T {\n    return visitor.visitLiteralExpr(this)\n  }\n}\n\nexport class Unary implements Expr {\n  constructor(readonly operator: Token, readonly right: Expr) {}\n\n  accept<T>(visitor: Visitor<T>): T {\n    return visitor.visitUnaryExpr(this)\n  }\n}\n\nexport class Variable implements Expr {\n  constructor(readonly name: Token) {}\n\n  accept<T>(visitor: Visitor<T>): T {\n    return visitor.visitVariableExpr(this)\n  }\n}\n\nexport class Assign implements Expr {\n  constructor(readonly variable: Variable, readonly value: Expr) {}\n\n  accept<T>(visitor: Visitor<T>): T {\n    return visitor.visitAssignExpr(this)\n  }\n}\n\nexport class Call implements Expr {\n  constructor(\n    readonly callee: Expr,\n    readonly paren: Token,\n    readonly args: Expr[]\n  ) {}\n\n  accept<T>(visitor: Visitor<T>): T {\n    return visitor.visitCallExpr(this)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}