{"ast":null,"code":"import { Token } from \"./token\";\nimport { TokenType } from \"./token-type\";\nimport { Result } from \"./common\";\nconst keywords = {\n  and: TokenType.AND,\n  class: TokenType.CLASS,\n  else: TokenType.ELSE,\n  false: TokenType.FALSE,\n  for: TokenType.FOR,\n  fun: TokenType.FUN,\n  if: TokenType.IF,\n  nil: TokenType.NIL,\n  or: TokenType.OR,\n  print: TokenType.PRINT,\n  return: TokenType.RETURN,\n  super: TokenType.SUPER,\n  this: TokenType.THIS,\n  true: TokenType.TRUE,\n  var: TokenType.VAR,\n  while: TokenType.WHILE,\n  break: TokenType.BREAK\n};\nexport class Scanner {\n  constructor(source) {\n    this.source = void 0;\n    this.tokens = [];\n    this.errors = [];\n    this.start = 0;\n    this.current = 0;\n    this.line = 1;\n    this.source = source;\n  }\n\n  static scan(source) {\n    return new Scanner(source).scanTokens();\n  }\n\n  scanTokens() {\n    while (!this.isAtEnd()) {\n      this.start = this.current;\n      this.scanToken();\n    }\n\n    this.tokens.push(new Token(TokenType.EOF, \"EOF\", null, this.line));\n\n    if (this.errors.length === 0) {\n      return Result.Ok(this.tokens);\n    }\n\n    return Result.Fail(this.errors);\n  }\n\n  scanToken() {\n    const c = this.advance();\n\n    switch (c) {\n      case \"(\":\n        this.addToken(TokenType.LEFT_PAREN);\n        break;\n\n      case \")\":\n        this.addToken(TokenType.RIGHT_PAREN);\n        break;\n\n      case \"{\":\n        this.addToken(TokenType.LEFT_BRACE);\n        break;\n\n      case \"}\":\n        this.addToken(TokenType.RIGHT_BRACE);\n        break;\n\n      case \",\":\n        this.addToken(TokenType.COMMA);\n        break;\n\n      case \".\":\n        this.addToken(TokenType.DOT);\n        break;\n\n      case \"-\":\n        this.addToken(TokenType.MINUS);\n        break;\n\n      case \"+\":\n        this.addToken(TokenType.PLUS);\n        break;\n\n      case \";\":\n        this.addToken(TokenType.SEMICOLON);\n        break;\n\n      case \"*\":\n        this.addToken(TokenType.STAR);\n        break;\n\n      case \"?\":\n        this.addToken(TokenType.QUESTION);\n        break;\n\n      case \":\":\n        this.addToken(TokenType.COLON);\n        break;\n\n      case \"!\":\n        this.addToken(this.match(\"=\") ? TokenType.BANG_EQUAL : TokenType.BANG);\n        break;\n\n      case \"=\":\n        this.addToken(this.match(\"=\") ? TokenType.EQUAL_EQUAL : TokenType.EQUAL);\n        break;\n\n      case \"<\":\n        this.addToken(this.match(\"=\") ? TokenType.LESS_EQUAL : TokenType.LESS);\n        break;\n\n      case \">\":\n        this.addToken(this.match(\"=\") ? TokenType.GREATER_EQUAL : TokenType.GREATER);\n        break;\n\n      case \"/\":\n        if (this.match(\"/\")) {\n          while (this.peek() !== \"\\n\" && !this.isAtEnd()) {\n            this.advance();\n          }\n        } else if (this.match(\"*\")) {\n          while (!this.isAtEnd() && !(this.peek() === \"*\" && this.peekNext() === \"/\")) {\n            if (this.peek() === \"\\n\") {\n              this.line += 1;\n            }\n\n            this.advance();\n          }\n\n          if (this.isAtEnd()) {\n            this.error(this.line, \"Unterminated multiline comment\");\n          } else {\n            this.advance();\n            this.advance();\n          }\n        } else {\n          this.addToken(TokenType.SLASH);\n        }\n\n        break;\n\n      case \" \":\n      case \"\\t\":\n      case \"\\r\":\n        break;\n\n      case \"\\n\":\n        this.line += 1;\n        break;\n\n      case '\"':\n        this.scanString();\n        break;\n\n      default:\n        if (this.isDigit(c)) {\n          this.scanNumber();\n        } else if (this.isAlpha(c)) {\n          this.scanIdentifier();\n        } else {\n          this.error(this.line, `Unexpected character \"${c}\"`);\n        }\n\n    }\n  }\n\n  scanString() {\n    while (this.peek() !== '\"' && !this.isAtEnd()) {\n      if (this.peek() === \"\\n\") {\n        this.line += 1;\n      }\n\n      this.advance();\n    }\n\n    if (this.isAtEnd()) {\n      this.error(this.line, \"Unterminated string\");\n      return;\n    }\n\n    this.advance();\n    this.addToken(TokenType.STRING, this.source.slice(this.start + 1, this.current - 1));\n  }\n\n  scanNumber() {\n    while (this.isDigit(this.peek())) {\n      this.advance();\n    }\n\n    if (this.peek() === \".\" && this.isDigit(this.peekNext())) {\n      this.advance();\n\n      while (this.isDigit(this.peek())) {\n        this.advance();\n      }\n    }\n\n    this.addToken(TokenType.NUMBER, Number(this.source.slice(this.start, this.current)));\n  }\n\n  scanIdentifier() {\n    while (this.isAlphaNumeric(this.peek())) {\n      this.advance();\n    }\n\n    const identifier = this.source.slice(this.start, this.current);\n    const type = keywords[identifier];\n    this.addToken(type || TokenType.IDENTIFIER);\n  }\n\n  advance() {\n    this.current += 1;\n    return this.source[this.current - 1];\n  }\n\n  match(expected) {\n    if (this.isAtEnd() || this.source[this.current] !== expected) {\n      return false;\n    }\n\n    this.current += 1;\n    return true;\n  }\n\n  peek() {\n    if (this.isAtEnd()) {\n      return \"\\0\";\n    }\n\n    return this.source[this.current];\n  }\n\n  peekNext() {\n    if (this.current + 1 >= this.source.length) {\n      return \"\\0\";\n    }\n\n    return this.source[this.current + 1];\n  }\n\n  addToken(type, literal = null) {\n    const text = this.source.slice(this.start, this.current);\n    this.tokens.push(new Token(type, text, literal, this.line));\n  }\n\n  error(line, message) {\n    this.errors.push({\n      line,\n      message\n    });\n  }\n\n  isAtEnd() {\n    return this.current >= this.source.length;\n  }\n\n  isDigit(c) {\n    return c >= \"0\" && c <= \"9\";\n  }\n\n  isAlpha(c) {\n    return c >= \"a\" && c <= \"z\" || c >= \"A\" && c <= \"Z\" || c == \"_\";\n  }\n\n  isAlphaNumeric(c) {\n    return this.isAlpha(c) || this.isDigit(c);\n  }\n\n}","map":{"version":3,"sources":["/home/chriz/Documents/kame-code/src/logic/tslox/scanner.ts"],"names":["Token","TokenType","Result","keywords","and","AND","class","CLASS","else","ELSE","false","FALSE","for","FOR","fun","FUN","if","IF","nil","NIL","or","OR","print","PRINT","return","RETURN","super","SUPER","this","THIS","true","TRUE","var","VAR","while","WHILE","break","BREAK","Scanner","constructor","source","tokens","errors","start","current","line","scan","scanTokens","isAtEnd","scanToken","push","EOF","length","Ok","Fail","c","advance","addToken","LEFT_PAREN","RIGHT_PAREN","LEFT_BRACE","RIGHT_BRACE","COMMA","DOT","MINUS","PLUS","SEMICOLON","STAR","QUESTION","COLON","match","BANG_EQUAL","BANG","EQUAL_EQUAL","EQUAL","LESS_EQUAL","LESS","GREATER_EQUAL","GREATER","peek","peekNext","error","SLASH","scanString","isDigit","scanNumber","isAlpha","scanIdentifier","STRING","slice","NUMBER","Number","isAlphaNumeric","identifier","type","IDENTIFIER","expected","literal","text","message"],"mappings":"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","sourcesContent":["import { Token, Literal } from \"./token\"\nimport { TokenType } from \"./token-type\"\nimport { Result } from \"./common\"\n\nexport interface ScanError {\n  line: number\n  message: string\n}\n\nconst keywords: Record<string, TokenType> = {\n  and: TokenType.AND,\n  class: TokenType.CLASS,\n  else: TokenType.ELSE,\n  false: TokenType.FALSE,\n  for: TokenType.FOR,\n  fun: TokenType.FUN,\n  if: TokenType.IF,\n  nil: TokenType.NIL,\n  or: TokenType.OR,\n  print: TokenType.PRINT,\n  return: TokenType.RETURN,\n  super: TokenType.SUPER,\n  this: TokenType.THIS,\n  true: TokenType.TRUE,\n  var: TokenType.VAR,\n  while: TokenType.WHILE,\n  break: TokenType.BREAK\n}\n\nexport class Scanner {\n  private readonly source: string\n  private readonly tokens: Token[] = []\n  private readonly errors: ScanError[] = []\n\n  private start: number = 0\n  private current: number = 0\n  private line: number = 1\n\n  constructor(source: string) {\n    this.source = source\n  }\n\n  static scan(source: string) {\n    return new Scanner(source).scanTokens()\n  }\n\n  scanTokens(): Result<Token[], ScanError[]> {\n    while (!this.isAtEnd()) {\n      this.start = this.current\n      this.scanToken()\n    }\n\n    this.tokens.push(new Token(TokenType.EOF, \"EOF\", null, this.line))\n\n    if (this.errors.length === 0) {\n      return Result.Ok(this.tokens)\n    }\n\n    return Result.Fail(this.errors)\n  }\n\n  private scanToken(): void {\n    const c = this.advance()\n\n    switch (c) {\n      case \"(\":\n        this.addToken(TokenType.LEFT_PAREN)\n        break\n      case \")\":\n        this.addToken(TokenType.RIGHT_PAREN)\n        break\n      case \"{\":\n        this.addToken(TokenType.LEFT_BRACE)\n        break\n      case \"}\":\n        this.addToken(TokenType.RIGHT_BRACE)\n        break\n      case \",\":\n        this.addToken(TokenType.COMMA)\n        break\n      case \".\":\n        this.addToken(TokenType.DOT)\n        break\n      case \"-\":\n        this.addToken(TokenType.MINUS)\n        break\n      case \"+\":\n        this.addToken(TokenType.PLUS)\n        break\n      case \";\":\n        this.addToken(TokenType.SEMICOLON)\n        break\n      case \"*\":\n        this.addToken(TokenType.STAR)\n        break\n      case \"?\":\n        this.addToken(TokenType.QUESTION)\n        break\n      case \":\":\n        this.addToken(TokenType.COLON)\n        break\n      case \"!\":\n        this.addToken(this.match(\"=\") ? TokenType.BANG_EQUAL : TokenType.BANG)\n        break\n      case \"=\":\n        this.addToken(this.match(\"=\") ? TokenType.EQUAL_EQUAL : TokenType.EQUAL)\n        break\n      case \"<\":\n        this.addToken(this.match(\"=\") ? TokenType.LESS_EQUAL : TokenType.LESS)\n        break\n      case \">\":\n        this.addToken(\n          this.match(\"=\") ? TokenType.GREATER_EQUAL : TokenType.GREATER\n        )\n        break\n      case \"/\":\n        if (this.match(\"/\")) {\n          while (this.peek() !== \"\\n\" && !this.isAtEnd()) {\n            this.advance()\n          }\n        } else if (this.match(\"*\")) {\n          while (\n            !this.isAtEnd() &&\n            !(this.peek() === \"*\" && this.peekNext() === \"/\")\n          ) {\n            if (this.peek() === \"\\n\") {\n              this.line += 1\n            }\n\n            this.advance()\n          }\n\n          if (this.isAtEnd()) {\n            this.error(this.line, \"Unterminated multiline comment\")\n          } else {\n            this.advance()\n            this.advance()\n          }\n        } else {\n          this.addToken(TokenType.SLASH)\n        }\n        break\n\n      case \" \":\n      case \"\\t\":\n      case \"\\r\":\n        break\n\n      case \"\\n\":\n        this.line += 1\n        break\n\n      case '\"':\n        this.scanString()\n        break\n\n      default:\n        if (this.isDigit(c)) {\n          this.scanNumber()\n        } else if (this.isAlpha(c)) {\n          this.scanIdentifier()\n        } else {\n          this.error(this.line, `Unexpected character \"${c}\"`)\n        }\n    }\n  }\n\n  private scanString(): void {\n    while (this.peek() !== '\"' && !this.isAtEnd()) {\n      if (this.peek() === \"\\n\") {\n        this.line += 1\n      }\n\n      this.advance()\n    }\n\n    if (this.isAtEnd()) {\n      this.error(this.line, \"Unterminated string\")\n      return\n    }\n\n    this.advance()\n\n    this.addToken(\n      TokenType.STRING,\n      this.source.slice(this.start + 1, this.current - 1)\n    )\n  }\n\n  private scanNumber(): void {\n    while (this.isDigit(this.peek())) {\n      this.advance()\n    }\n\n    if (this.peek() === \".\" && this.isDigit(this.peekNext())) {\n      this.advance()\n\n      while (this.isDigit(this.peek())) {\n        this.advance()\n      }\n    }\n\n    this.addToken(\n      TokenType.NUMBER,\n      Number(this.source.slice(this.start, this.current))\n    )\n  }\n\n  private scanIdentifier(): void {\n    while (this.isAlphaNumeric(this.peek())) {\n      this.advance()\n    }\n\n    const identifier = this.source.slice(this.start, this.current)\n    const type = keywords[identifier]\n\n    this.addToken(type || TokenType.IDENTIFIER)\n  }\n\n  private advance(): string {\n    this.current += 1\n\n    return this.source[this.current - 1]\n  }\n\n  private match(expected: string): boolean {\n    if (this.isAtEnd() || this.source[this.current] !== expected) {\n      return false\n    }\n\n    this.current += 1\n\n    return true\n  }\n\n  private peek(): string {\n    if (this.isAtEnd()) {\n      return \"\\0\"\n    }\n\n    return this.source[this.current]\n  }\n\n  private peekNext(): string {\n    if (this.current + 1 >= this.source.length) {\n      return \"\\0\"\n    }\n\n    return this.source[this.current + 1]\n  }\n\n  private addToken(type: TokenType, literal: Literal = null): void {\n    const text = this.source.slice(this.start, this.current)\n\n    this.tokens.push(new Token(type, text, literal, this.line))\n  }\n\n  private error(line: number, message: string): void {\n    this.errors.push({ line, message })\n  }\n\n  private isAtEnd(): boolean {\n    return this.current >= this.source.length\n  }\n\n  private isDigit(c: string) {\n    return c >= \"0\" && c <= \"9\"\n  }\n\n  private isAlpha(c: string): boolean {\n    return (c >= \"a\" && c <= \"z\") || (c >= \"A\" && c <= \"Z\") || c == \"_\"\n  }\n\n  private isAlphaNumeric(c: string): boolean {\n    return this.isAlpha(c) || this.isDigit(c)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}