{"ast":null,"code":"import { TokenType } from \"./token-type\";\nimport { Result, CustomError } from \"./common\";\nimport { Environment } from \"./environment\";\nimport { globals } from \"./globals\";\nimport { Callable, LoxFunction } from \"./callable\";\nexport class RuntimeError extends CustomError {\n  constructor(token, message) {\n    super(message);\n    this.token = token;\n    this.message = message;\n  }\n\n}\nexport class BreakSignal extends CustomError {}\nexport class ReturnSignal extends CustomError {\n  constructor(value) {\n    super(\"\");\n    this.value = value;\n  }\n\n}\nexport class Interpreter {\n  constructor() {\n    this.environment = globals;\n    this.locals = new Map();\n  }\n\n  static interpret(statements) {\n    return new Interpreter().interpret(statements);\n  }\n\n  interpret(statements) {\n    try {\n      return Result.Ok(this.exec(statements));\n    } catch (error) {\n      return Result.Fail(error);\n    }\n  }\n\n  exec(statements) {\n    if (!Array.isArray(statements)) {\n      return statements.accept(this);\n    }\n\n    return statements.reduce((_, s) => this.exec(s), null);\n  }\n\n  eval(expr) {\n    return expr.accept(this);\n  }\n\n  resolve(expr, depth) {\n    this.locals.set(expr, depth);\n  }\n\n  visitExpressionStmt(stmt) {\n    return this.eval(stmt.expression);\n  }\n\n  visitPrintStmt(stmt) {\n    console.log(stringify(this.eval(stmt.expression)));\n    return null;\n  }\n\n  visitVarStmt(stmt) {\n    const value = stmt.initializer ? this.eval(stmt.initializer) : null;\n    this.environment.define(stmt.variable.name, value);\n    return null;\n  }\n\n  visitFunctionStmt(stmt) {\n    const fun = new LoxFunction(stmt, this.environment);\n    this.environment.define(stmt.name, fun);\n    return null;\n  }\n\n  visitBlockStmt(stmt) {\n    return this.execBlock(stmt, new Environment(this.environment));\n  }\n\n  visitIfStmt(stmt) {\n    if (isTruthy(this.eval(stmt.condition))) {\n      this.exec(stmt.thenBranch);\n    } else if (stmt.elseBranch) {\n      this.exec(stmt.elseBranch);\n    }\n\n    return null;\n  }\n\n  visitWhileStmt(stmt) {\n    while (isTruthy(this.eval(stmt.condition))) {\n      try {\n        this.exec(stmt.body);\n      } catch (error) {\n        if (error instanceof BreakSignal) {\n          break;\n        }\n\n        throw error;\n      }\n    }\n\n    return null;\n  }\n\n  visitBreakStmt(_stmt) {\n    throw new BreakSignal();\n  }\n\n  visitReturnStmt(stmt) {\n    const value = stmt.value ? this.eval(stmt.value) : null;\n    throw new ReturnSignal(value);\n  }\n\n  visitVariableExpr(expr) {\n    return this.lookUpVariable(expr.name, expr);\n  }\n\n  visitAssignExpr(expr) {\n    const value = this.eval(expr.value);\n    const distance = this.locals.get(expr);\n\n    if (distance !== undefined) {\n      this.environment.assignAt(distance, expr.variable.name, value);\n    } else {\n      globals.assign(expr.variable.name, value);\n    }\n\n    this.environment.assign(expr.variable.name, value);\n    return value;\n  }\n\n  visitBinaryExpr(expr) {\n    const op = binaryOperators[expr.operator.type];\n\n    if (op) {\n      return op(expr.operator, this.eval(expr.left), this.eval(expr.right));\n    }\n\n    throw new Error();\n  }\n\n  visitTernaryExpr(expr) {\n    if (isTruthy(this.eval(expr.condition))) {\n      return this.eval(expr.left);\n    }\n\n    return this.eval(expr.right);\n  }\n\n  visitLogicalExpr(expr) {\n    const left = this.eval(expr.left);\n\n    if (expr.operator.type === TokenType.OR) {\n      if (isTruthy(left)) {\n        return left;\n      }\n    } else if (!isTruthy(left)) {\n      return left;\n    }\n\n    return this.eval(expr.right);\n  }\n\n  visitGroupingExpr(expr) {\n    return this.eval(expr.expression);\n  }\n\n  visitLiteralExpr(expr) {\n    return expr.value;\n  }\n\n  visitUnaryExpr(expr) {\n    const op = unaryOperators[expr.operator.type];\n\n    if (op) {\n      return op(expr.operator, this.eval(expr.right));\n    }\n\n    throw new Error();\n  }\n\n  visitCallExpr(expr) {\n    const callee = this.eval(expr.callee);\n    const args = expr.args.map(a => this.eval(a));\n\n    if (!(callee instanceof Callable)) {\n      throw new RuntimeError(expr.paren, \"Can only call functions and classes\");\n    }\n\n    if (args.length !== callee.getArity()) {\n      throw new RuntimeError(expr.paren, `Expected ${callee.getArity()} arguments but got ${args.length}`);\n    }\n\n    return callee.call(this, args);\n  }\n\n  execBlock(block, environment) {\n    const previous = this.environment;\n\n    try {\n      this.environment = environment;\n      this.exec(block.statements);\n      return null;\n    } finally {\n      this.environment = previous;\n    }\n  }\n\n  lookUpVariable(name, expr) {\n    const distance = this.locals.get(expr);\n\n    if (distance !== undefined) {\n      return this.environment.getAt(distance, name);\n    } else {\n      return globals.get(name);\n    }\n  }\n\n}\nexport const isString = v => typeof v === \"string\";\nexport const isNumber = v => typeof v === \"number\";\nexport const isNil = v => v === null;\nexport const isTruthy = v => v !== null && v !== false;\nexport const stringify = v => isNil(v) ? \"nil\" : v.toString();\n\nconst checkOperands = (assert, message, next) => func => (operator, ...operands) => {\n  if (operands.every(assert)) {\n    return func(...operands);\n  }\n\n  if (next) {\n    return next(func)(operator, ...operands);\n  }\n\n  throw new RuntimeError(operator, message);\n};\n\nconst checkNumberOperands = checkOperands(isNumber, \"Operands must be a number\");\nconst numberOrStringErrorMessage = \"Operands must be two numbers or two strings\";\nconst checkNumberOrStringOperands = checkOperands(isNumber, numberOrStringErrorMessage, checkOperands(isString, numberOrStringErrorMessage));\nconst unaryOperators = {\n  [TokenType.BANG]: (_, v) => !isTruthy(v),\n  [TokenType.MINUS]: checkNumberOperands(v => -v)\n};\n\nconst binaryPlusOperator = (op, a, b) => {\n  if (isNumber(a) && isNumber(b)) {\n    return a + b;\n  }\n\n  if (isString(a) || isString(b)) {\n    return stringify(a) + stringify(b);\n  }\n\n  throw new RuntimeError(op, \"Operands must be two numbers or one of them must be a string\");\n};\n\nconst binarySlashOperator = (op, a, b) => {\n  if (b === 0) {\n    throw new RuntimeError(op, \"Division by zero\");\n  }\n\n  return checkNumberOperands((a, b) => a / b)(op, a, b);\n};\n\nconst binaryOperators = {\n  [TokenType.PLUS]: binaryPlusOperator,\n  [TokenType.MINUS]: checkNumberOperands((a, b) => a - b),\n  [TokenType.SLASH]: binarySlashOperator,\n  [TokenType.STAR]: checkNumberOperands((a, b) => a * b),\n  [TokenType.GREATER]: checkNumberOrStringOperands((a, b) => a > b),\n  [TokenType.GREATER_EQUAL]: checkNumberOrStringOperands((a, b) => a >= b),\n  [TokenType.LESS]: checkNumberOrStringOperands((a, b) => a < b),\n  [TokenType.LESS_EQUAL]: checkNumberOrStringOperands((a, b) => a <= b),\n  [TokenType.EQUAL_EQUAL]: (_, a, b) => a === b,\n  [TokenType.BANG_EQUAL]: (_, a, b) => a !== b\n};","map":{"version":3,"sources":["/home/chriz/Documents/kame-code/src/logic/tslox/interpreter.ts"],"names":["TokenType","Result","CustomError","Environment","globals","Callable","LoxFunction","RuntimeError","constructor","token","message","BreakSignal","ReturnSignal","value","Interpreter","environment","locals","Map","interpret","statements","Ok","exec","error","Fail","Array","isArray","accept","reduce","_","s","eval","expr","resolve","depth","set","visitExpressionStmt","stmt","expression","visitPrintStmt","console","log","stringify","visitVarStmt","initializer","define","variable","name","visitFunctionStmt","fun","visitBlockStmt","execBlock","visitIfStmt","isTruthy","condition","thenBranch","elseBranch","visitWhileStmt","body","visitBreakStmt","_stmt","visitReturnStmt","visitVariableExpr","lookUpVariable","visitAssignExpr","distance","get","undefined","assignAt","assign","visitBinaryExpr","op","binaryOperators","operator","type","left","right","Error","visitTernaryExpr","visitLogicalExpr","OR","visitGroupingExpr","visitLiteralExpr","visitUnaryExpr","unaryOperators","visitCallExpr","callee","args","map","a","paren","length","getArity","call","block","previous","getAt","isString","v","isNumber","isNil","toString","checkOperands","assert","next","func","operands","every","checkNumberOperands","numberOrStringErrorMessage","checkNumberOrStringOperands","BANG","MINUS","binaryPlusOperator","b","binarySlashOperator","PLUS","SLASH","STAR","GREATER","GREATER_EQUAL","LESS","LESS_EQUAL","EQUAL_EQUAL","BANG_EQUAL"],"mappings":"AAEA,SAASA,SAAT,QAA0B,cAA1B;AAEA,SAASC,MAAT,EAAiBC,WAAjB,QAAoC,UAApC;AACA,SAASC,WAAT,QAA4B,eAA5B;AACA,SAASC,OAAT,QAAwB,WAAxB;AACA,SAASC,QAAT,EAAmBC,WAAnB,QAAsC,YAAtC;AAIA,OAAO,MAAMC,YAAN,SAA2BL,WAA3B,CAAuC;AAC5CM,EAAAA,WAAW,CAAQC,KAAR,EAA6BC,OAA7B,EAA8C;AACvD,UAAMA,OAAN;AADuD,SAAtCD,KAAsC,GAAtCA,KAAsC;AAAA,SAAjBC,OAAiB,GAAjBA,OAAiB;AAExD;;AAH2C;AAM9C,OAAO,MAAMC,WAAN,SAA0BT,WAA1B,CAAsC;AAE7C,OAAO,MAAMU,YAAN,SAA2BV,WAA3B,CAAuC;AAC5CM,EAAAA,WAAW,CAAUK,KAAV,EAA2B;AACpC,UAAM,EAAN;AADoC,SAAjBA,KAAiB,GAAjBA,KAAiB;AAErC;;AAH2C;AAM9C,OAAO,MAAMC,WAAN,CACqD;AAAA;AAAA,SAKlDC,WALkD,GAKpCX,OALoC;AAAA,SAMlDY,MANkD,GAMzC,IAAIC,GAAJ,EANyC;AAAA;;AAC1D,SAAOC,SAAP,CAAiBC,UAAjB,EAA0C;AACxC,WAAO,IAAIL,WAAJ,GAAkBI,SAAlB,CAA4BC,UAA5B,CAAP;AACD;;AAKDD,EAAAA,SAAS,CAACC,UAAD,EAA0D;AACjE,QAAI;AACF,aAAOlB,MAAM,CAACmB,EAAP,CAAU,KAAKC,IAAL,CAAUF,UAAV,CAAV,CAAP;AACD,KAFD,CAEE,OAAOG,KAAP,EAAc;AACd,aAAOrB,MAAM,CAACsB,IAAP,CAAYD,KAAZ,CAAP;AACD;AACF;;AAKDD,EAAAA,IAAI,CAACF,UAAD,EAAgD;AAClD,QAAI,CAACK,KAAK,CAACC,OAAN,CAAcN,UAAd,CAAL,EAAgC;AAC9B,aAAOA,UAAU,CAACO,MAAX,CAAkB,IAAlB,CAAP;AACD;;AAED,WAAOP,UAAU,CAACQ,MAAX,CAAkB,CAACC,CAAD,EAAIC,CAAJ,KAAU,KAAKR,IAAL,CAAUQ,CAAV,CAA5B,EAA0C,IAA1C,CAAP;AACD;;AAEDC,EAAAA,IAAI,CAACC,IAAD,EAA4B;AAC9B,WAAOA,IAAI,CAACL,MAAL,CAAY,IAAZ,CAAP;AACD;;AAEDM,EAAAA,OAAO,CAACD,IAAD,EAAkBE,KAAlB,EAAuC;AAC5C,SAAKjB,MAAL,CAAYkB,GAAZ,CAAgBH,IAAhB,EAAsBE,KAAtB;AACD;;AAEDE,EAAAA,mBAAmB,CAACC,IAAD,EAAkC;AACnD,WAAO,KAAKN,IAAL,CAAUM,IAAI,CAACC,UAAf,CAAP;AACD;;AAEDC,EAAAA,cAAc,CAACF,IAAD,EAA6B;AACzCG,IAAAA,OAAO,CAACC,GAAR,CAAYC,SAAS,CAAC,KAAKX,IAAL,CAAUM,IAAI,CAACC,UAAf,CAAD,CAArB;AACA,WAAO,IAAP;AACD;;AAEDK,EAAAA,YAAY,CAACN,IAAD,EAA2B;AACrC,UAAMvB,KAAK,GAAGuB,IAAI,CAACO,WAAL,GAAmB,KAAKb,IAAL,CAAUM,IAAI,CAACO,WAAf,CAAnB,GAAiD,IAA/D;AAEA,SAAK5B,WAAL,CAAiB6B,MAAjB,CAAwBR,IAAI,CAACS,QAAL,CAAcC,IAAtC,EAA4CjC,KAA5C;AAEA,WAAO,IAAP;AACD;;AAEDkC,EAAAA,iBAAiB,CAACX,IAAD,EAAgC;AAC/C,UAAMY,GAAG,GAAG,IAAI1C,WAAJ,CAAgB8B,IAAhB,EAAsB,KAAKrB,WAA3B,CAAZ;AAEA,SAAKA,WAAL,CAAiB6B,MAAjB,CAAwBR,IAAI,CAACU,IAA7B,EAAmCE,GAAnC;AAEA,WAAO,IAAP;AACD;;AAEDC,EAAAA,cAAc,CAACb,IAAD,EAA6B;AACzC,WAAO,KAAKc,SAAL,CAAed,IAAf,EAAqB,IAAIjC,WAAJ,CAAgB,KAAKY,WAArB,CAArB,CAAP;AACD;;AAEDoC,EAAAA,WAAW,CAACf,IAAD,EAA0B;AACnC,QAAIgB,QAAQ,CAAC,KAAKtB,IAAL,CAAUM,IAAI,CAACiB,SAAf,CAAD,CAAZ,EAAyC;AACvC,WAAKhC,IAAL,CAAUe,IAAI,CAACkB,UAAf;AACD,KAFD,MAEO,IAAIlB,IAAI,CAACmB,UAAT,EAAqB;AAC1B,WAAKlC,IAAL,CAAUe,IAAI,CAACmB,UAAf;AACD;;AAED,WAAO,IAAP;AACD;;AAEDC,EAAAA,cAAc,CAACpB,IAAD,EAA6B;AACzC,WAAOgB,QAAQ,CAAC,KAAKtB,IAAL,CAAUM,IAAI,CAACiB,SAAf,CAAD,CAAf,EAA4C;AAC1C,UAAI;AACF,aAAKhC,IAAL,CAAUe,IAAI,CAACqB,IAAf;AACD,OAFD,CAEE,OAAOnC,KAAP,EAAc;AACd,YAAIA,KAAK,YAAYX,WAArB,EAAkC;AAChC;AACD;;AAED,cAAMW,KAAN;AACD;AACF;;AAED,WAAO,IAAP;AACD;;AAEDoC,EAAAA,cAAc,CAACC,KAAD,EAA8B;AAC1C,UAAM,IAAIhD,WAAJ,EAAN;AACD;;AAEDiD,EAAAA,eAAe,CAACxB,IAAD,EAA8B;AAC3C,UAAMvB,KAAK,GAAGuB,IAAI,CAACvB,KAAL,GAAa,KAAKiB,IAAL,CAAUM,IAAI,CAACvB,KAAf,CAAb,GAAqC,IAAnD;AAEA,UAAM,IAAID,YAAJ,CAAiBC,KAAjB,CAAN;AACD;;AAEDgD,EAAAA,iBAAiB,CAAC9B,IAAD,EAAgC;AAC/C,WAAO,KAAK+B,cAAL,CAAoB/B,IAAI,CAACe,IAAzB,EAA+Bf,IAA/B,CAAP;AACD;;AAEDgC,EAAAA,eAAe,CAAChC,IAAD,EAA8B;AAC3C,UAAMlB,KAAK,GAAG,KAAKiB,IAAL,CAAUC,IAAI,CAAClB,KAAf,CAAd;AACA,UAAMmD,QAAQ,GAAG,KAAKhD,MAAL,CAAYiD,GAAZ,CAAgBlC,IAAhB,CAAjB;;AAEA,QAAIiC,QAAQ,KAAKE,SAAjB,EAA4B;AAC1B,WAAKnD,WAAL,CAAiBoD,QAAjB,CAA0BH,QAA1B,EAAoCjC,IAAI,CAACc,QAAL,CAAcC,IAAlD,EAAwDjC,KAAxD;AACD,KAFD,MAEO;AACLT,MAAAA,OAAO,CAACgE,MAAR,CAAerC,IAAI,CAACc,QAAL,CAAcC,IAA7B,EAAmCjC,KAAnC;AACD;;AAED,SAAKE,WAAL,CAAiBqD,MAAjB,CAAwBrC,IAAI,CAACc,QAAL,CAAcC,IAAtC,EAA4CjC,KAA5C;AAEA,WAAOA,KAAP;AACD;;AAEDwD,EAAAA,eAAe,CAACtC,IAAD,EAA8B;AAC3C,UAAMuC,EAAE,GAAGC,eAAe,CAACxC,IAAI,CAACyC,QAAL,CAAcC,IAAf,CAA1B;;AAEA,QAAIH,EAAJ,EAAQ;AACN,aAAOA,EAAE,CAACvC,IAAI,CAACyC,QAAN,EAAgB,KAAK1C,IAAL,CAAUC,IAAI,CAAC2C,IAAf,CAAhB,EAAsC,KAAK5C,IAAL,CAAUC,IAAI,CAAC4C,KAAf,CAAtC,CAAT;AACD;;AAED,UAAM,IAAIC,KAAJ,EAAN;AACD;;AAEDC,EAAAA,gBAAgB,CAAC9C,IAAD,EAA+B;AAC7C,QAAIqB,QAAQ,CAAC,KAAKtB,IAAL,CAAUC,IAAI,CAACsB,SAAf,CAAD,CAAZ,EAAyC;AACvC,aAAO,KAAKvB,IAAL,CAAUC,IAAI,CAAC2C,IAAf,CAAP;AACD;;AAED,WAAO,KAAK5C,IAAL,CAAUC,IAAI,CAAC4C,KAAf,CAAP;AACD;;AAEDG,EAAAA,gBAAgB,CAAC/C,IAAD,EAA+B;AAC7C,UAAM2C,IAAI,GAAG,KAAK5C,IAAL,CAAUC,IAAI,CAAC2C,IAAf,CAAb;;AAEA,QAAI3C,IAAI,CAACyC,QAAL,CAAcC,IAAd,KAAuBzE,SAAS,CAAC+E,EAArC,EAAyC;AACvC,UAAI3B,QAAQ,CAACsB,IAAD,CAAZ,EAAoB;AAClB,eAAOA,IAAP;AACD;AACF,KAJD,MAIO,IAAI,CAACtB,QAAQ,CAACsB,IAAD,CAAb,EAAqB;AAC1B,aAAOA,IAAP;AACD;;AAED,WAAO,KAAK5C,IAAL,CAAUC,IAAI,CAAC4C,KAAf,CAAP;AACD;;AAEDK,EAAAA,iBAAiB,CAACjD,IAAD,EAAgC;AAC/C,WAAO,KAAKD,IAAL,CAAUC,IAAI,CAACM,UAAf,CAAP;AACD;;AAED4C,EAAAA,gBAAgB,CAAClD,IAAD,EAA+B;AAC7C,WAAOA,IAAI,CAAClB,KAAZ;AACD;;AAEDqE,EAAAA,cAAc,CAACnD,IAAD,EAA6B;AACzC,UAAMuC,EAAE,GAAGa,cAAc,CAACpD,IAAI,CAACyC,QAAL,CAAcC,IAAf,CAAzB;;AAEA,QAAIH,EAAJ,EAAQ;AACN,aAAOA,EAAE,CAACvC,IAAI,CAACyC,QAAN,EAAgB,KAAK1C,IAAL,CAAUC,IAAI,CAAC4C,KAAf,CAAhB,CAAT;AACD;;AAED,UAAM,IAAIC,KAAJ,EAAN;AACD;;AAEDQ,EAAAA,aAAa,CAACrD,IAAD,EAA4B;AACvC,UAAMsD,MAAM,GAAG,KAAKvD,IAAL,CAAUC,IAAI,CAACsD,MAAf,CAAf;AACA,UAAMC,IAAI,GAAGvD,IAAI,CAACuD,IAAL,CAAUC,GAAV,CAAcC,CAAC,IAAI,KAAK1D,IAAL,CAAU0D,CAAV,CAAnB,CAAb;;AAEA,QAAI,EAAEH,MAAM,YAAYhF,QAApB,CAAJ,EAAmC;AACjC,YAAM,IAAIE,YAAJ,CAAiBwB,IAAI,CAAC0D,KAAtB,EAA6B,qCAA7B,CAAN;AACD;;AAED,QAAIH,IAAI,CAACI,MAAL,KAAgBL,MAAM,CAACM,QAAP,EAApB,EAAuC;AACrC,YAAM,IAAIpF,YAAJ,CACJwB,IAAI,CAAC0D,KADD,EAEH,YAAWJ,MAAM,CAACM,QAAP,EAAkB,sBAAqBL,IAAI,CAACI,MAAO,EAF3D,CAAN;AAID;;AAED,WAAOL,MAAM,CAACO,IAAP,CAAY,IAAZ,EAAkBN,IAAlB,CAAP;AACD;;AAEDpC,EAAAA,SAAS,CAAC2C,KAAD,EAAoB9E,WAApB,EAAwD;AAC/D,UAAM+E,QAAQ,GAAG,KAAK/E,WAAtB;;AAEA,QAAI;AACF,WAAKA,WAAL,GAAmBA,WAAnB;AAEA,WAAKM,IAAL,CAAUwE,KAAK,CAAC1E,UAAhB;AAEA,aAAO,IAAP;AACD,KAND,SAMU;AACR,WAAKJ,WAAL,GAAmB+E,QAAnB;AACD;AACF;;AAEDhC,EAAAA,cAAc,CAAChB,IAAD,EAAcf,IAAd,EAAyC;AACrD,UAAMiC,QAAQ,GAAG,KAAKhD,MAAL,CAAYiD,GAAZ,CAAgBlC,IAAhB,CAAjB;;AAEA,QAAIiC,QAAQ,KAAKE,SAAjB,EAA4B;AAC1B,aAAO,KAAKnD,WAAL,CAAiBgF,KAAjB,CAAuB/B,QAAvB,EAAiClB,IAAjC,CAAP;AACD,KAFD,MAEO;AACL,aAAO1C,OAAO,CAAC6D,GAAR,CAAYnB,IAAZ,CAAP;AACD;AACF;;AAjNyD;AAoN5D,OAAO,MAAMkD,QAAQ,GAAIC,CAAD,IAA8B,OAAOA,CAAP,KAAa,QAA5D;AAEP,OAAO,MAAMC,QAAQ,GAAID,CAAD,IAA8B,OAAOA,CAAP,KAAa,QAA5D;AAEP,OAAO,MAAME,KAAK,GAAIF,CAAD,IAA4BA,CAAC,KAAK,IAAhD;AAEP,OAAO,MAAM7C,QAAQ,GAAI6C,CAAD,IAAiBA,CAAC,KAAK,IAAN,IAAcA,CAAC,KAAK,KAAtD;AAEP,OAAO,MAAMxD,SAAS,GAAIwD,CAAD,IACvBE,KAAK,CAACF,CAAD,CAAL,GAAW,KAAX,GAAmBA,CAAC,CAACG,QAAF,EADd;;AAGP,MAAMC,aAAa,GAAG,CACpBC,MADoB,EAEpB5F,OAFoB,EAGpB6F,IAHoB,KAIhBC,IAAD,IAA0C,CAC7ChC,QAD6C,EAE7C,GAAGiC,QAF0C,KAGhC;AACb,MAAIA,QAAQ,CAACC,KAAT,CAAeJ,MAAf,CAAJ,EAA4B;AAC1B,WAAOE,IAAI,CAAC,GAAIC,QAAL,CAAX;AACD;;AAED,MAAIF,IAAJ,EAAU;AACR,WAAOA,IAAI,CAACC,IAAD,CAAJ,CAAWhC,QAAX,EAAqB,GAAGiC,QAAxB,CAAP;AACD;;AAED,QAAM,IAAIlG,YAAJ,CAAiBiE,QAAjB,EAA2B9D,OAA3B,CAAN;AACD,CAjBD;;AAmBA,MAAMiG,mBAAmB,GAAGN,aAAa,CAACH,QAAD,EAAW,2BAAX,CAAzC;AAEA,MAAMU,0BAA0B,GAAG,6CAAnC;AACA,MAAMC,2BAA2B,GAAGR,aAAa,CAC/CH,QAD+C,EAE/CU,0BAF+C,EAG/CP,aAAa,CAACL,QAAD,EAAWY,0BAAX,CAHkC,CAAjD;AAUA,MAAMzB,cAA4B,GAAG;AACnC,GAACnF,SAAS,CAAC8G,IAAX,GAAkB,CAAClF,CAAD,EAAIqE,CAAJ,KAAU,CAAC7C,QAAQ,CAAC6C,CAAD,CADF;AAEnC,GAACjG,SAAS,CAAC+G,KAAX,GAAmBJ,mBAAmB,CAACV,CAAC,IAAI,CAACA,CAAP;AAFH,CAArC;;AAKA,MAAMe,kBAAkB,GAAG,CAAC1C,EAAD,EAAYkB,CAAZ,EAAyByB,CAAzB,KAAmD;AAC5E,MAAIf,QAAQ,CAACV,CAAD,CAAR,IAAeU,QAAQ,CAACe,CAAD,CAA3B,EAAgC;AAC9B,WAAOzB,CAAC,GAAGyB,CAAX;AACD;;AAED,MAAIjB,QAAQ,CAACR,CAAD,CAAR,IAAeQ,QAAQ,CAACiB,CAAD,CAA3B,EAAgC;AAC9B,WAAOxE,SAAS,CAAC+C,CAAD,CAAT,GAAe/C,SAAS,CAACwE,CAAD,CAA/B;AACD;;AAED,QAAM,IAAI1G,YAAJ,CACJ+D,EADI,EAEJ,8DAFI,CAAN;AAID,CAbD;;AAeA,MAAM4C,mBAAmB,GAAG,CAAC5C,EAAD,EAAYkB,CAAZ,EAAyByB,CAAzB,KAAmD;AAC7E,MAAIA,CAAC,KAAK,CAAV,EAAa;AACX,UAAM,IAAI1G,YAAJ,CAAiB+D,EAAjB,EAAqB,kBAArB,CAAN;AACD;;AAED,SAAOqC,mBAAmB,CAAC,CAACnB,CAAD,EAAIyB,CAAJ,KAAUzB,CAAC,GAAGyB,CAAf,CAAnB,CAAqC3C,EAArC,EAAyCkB,CAAzC,EAA4CyB,CAA5C,CAAP;AACD,CAND;;AAQA,MAAM1C,eAA6B,GAAG;AACpC,GAACvE,SAAS,CAACmH,IAAX,GAAkBH,kBADkB;AAEpC,GAAChH,SAAS,CAAC+G,KAAX,GAAmBJ,mBAAmB,CAAC,CAACnB,CAAD,EAAIyB,CAAJ,KAAUzB,CAAC,GAAGyB,CAAf,CAFF;AAGpC,GAACjH,SAAS,CAACoH,KAAX,GAAmBF,mBAHiB;AAIpC,GAAClH,SAAS,CAACqH,IAAX,GAAkBV,mBAAmB,CAAC,CAACnB,CAAD,EAAIyB,CAAJ,KAAUzB,CAAC,GAAGyB,CAAf,CAJD;AAMpC,GAACjH,SAAS,CAACsH,OAAX,GAAqBT,2BAA2B,CAAC,CAACrB,CAAD,EAAIyB,CAAJ,KAAUzB,CAAC,GAAGyB,CAAf,CANZ;AAOpC,GAACjH,SAAS,CAACuH,aAAX,GAA2BV,2BAA2B,CAAC,CAACrB,CAAD,EAAIyB,CAAJ,KAAUzB,CAAC,IAAIyB,CAAhB,CAPlB;AAQpC,GAACjH,SAAS,CAACwH,IAAX,GAAkBX,2BAA2B,CAAC,CAACrB,CAAD,EAAIyB,CAAJ,KAAUzB,CAAC,GAAGyB,CAAf,CART;AASpC,GAACjH,SAAS,CAACyH,UAAX,GAAwBZ,2BAA2B,CAAC,CAACrB,CAAD,EAAIyB,CAAJ,KAAUzB,CAAC,IAAIyB,CAAhB,CATf;AAWpC,GAACjH,SAAS,CAAC0H,WAAX,GAAyB,CAAC9F,CAAD,EAAI4D,CAAJ,EAAOyB,CAAP,KAAazB,CAAC,KAAKyB,CAXR;AAYpC,GAACjH,SAAS,CAAC2H,UAAX,GAAwB,CAAC/F,CAAD,EAAI4D,CAAJ,EAAOyB,CAAP,KAAazB,CAAC,KAAKyB;AAZP,CAAtC","sourcesContent":["import * as Expr from \"./expr\"\nimport * as Stmt from \"./stmt\"\nimport { TokenType } from \"./token-type\"\nimport { Literal, Token } from \"./token\"\nimport { Result, CustomError } from \"./common\"\nimport { Environment } from \"./environment\"\nimport { globals } from \"./globals\"\nimport { Callable, LoxFunction } from \"./callable\"\n\nexport type LoxValue = Literal | Callable\n\nexport class RuntimeError extends CustomError {\n  constructor(public token: Token, public message: string) {\n    super(message)\n  }\n}\n\nexport class BreakSignal extends CustomError {}\n\nexport class ReturnSignal extends CustomError {\n  constructor(readonly value: LoxValue) {\n    super(\"\")\n  }\n}\n\nexport class Interpreter\n  implements Expr.Visitor<LoxValue>, Stmt.Visitor<LoxValue> {\n  static interpret(statements: Stmt.Stmt[]) {\n    return new Interpreter().interpret(statements)\n  }\n\n  private environment = globals\n  private locals = new Map<Expr.Expr, number>()\n\n  interpret(statements: Stmt.Stmt[]): Result<LoxValue, RuntimeError> {\n    try {\n      return Result.Ok(this.exec(statements))\n    } catch (error) {\n      return Result.Fail(error)\n    }\n  }\n\n  exec(statements: Stmt.Stmt[]): LoxValue\n  exec(statements: Stmt.Stmt): LoxValue\n\n  exec(statements: Stmt.Stmt | Stmt.Stmt[]): LoxValue {\n    if (!Array.isArray(statements)) {\n      return statements.accept(this)\n    }\n\n    return statements.reduce((_, s) => this.exec(s), null as LoxValue)\n  }\n\n  eval(expr: Expr.Expr): LoxValue {\n    return expr.accept(this)\n  }\n\n  resolve(expr: Expr.Expr, depth: number): void {\n    this.locals.set(expr, depth)\n  }\n\n  visitExpressionStmt(stmt: Stmt.Expression): LoxValue {\n    return this.eval(stmt.expression)\n  }\n\n  visitPrintStmt(stmt: Stmt.Print): LoxValue {\n    console.log(stringify(this.eval(stmt.expression)))\n    return null\n  }\n\n  visitVarStmt(stmt: Stmt.Var): LoxValue {\n    const value = stmt.initializer ? this.eval(stmt.initializer) : null\n\n    this.environment.define(stmt.variable.name, value)\n\n    return null\n  }\n\n  visitFunctionStmt(stmt: Stmt.Function): LoxValue {\n    const fun = new LoxFunction(stmt, this.environment)\n\n    this.environment.define(stmt.name, fun)\n\n    return null\n  }\n\n  visitBlockStmt(stmt: Stmt.Block): LoxValue {\n    return this.execBlock(stmt, new Environment(this.environment))\n  }\n\n  visitIfStmt(stmt: Stmt.If): LoxValue {\n    if (isTruthy(this.eval(stmt.condition))) {\n      this.exec(stmt.thenBranch)\n    } else if (stmt.elseBranch) {\n      this.exec(stmt.elseBranch)\n    }\n\n    return null\n  }\n\n  visitWhileStmt(stmt: Stmt.While): LoxValue {\n    while (isTruthy(this.eval(stmt.condition))) {\n      try {\n        this.exec(stmt.body)\n      } catch (error) {\n        if (error instanceof BreakSignal) {\n          break\n        }\n\n        throw error\n      }\n    }\n\n    return null\n  }\n\n  visitBreakStmt(_stmt: Stmt.Break): LoxValue {\n    throw new BreakSignal()\n  }\n\n  visitReturnStmt(stmt: Stmt.Return): LoxValue {\n    const value = stmt.value ? this.eval(stmt.value) : null\n\n    throw new ReturnSignal(value)\n  }\n\n  visitVariableExpr(expr: Expr.Variable): LoxValue {\n    return this.lookUpVariable(expr.name, expr)\n  }\n\n  visitAssignExpr(expr: Expr.Assign): LoxValue {\n    const value = this.eval(expr.value)\n    const distance = this.locals.get(expr)\n\n    if (distance !== undefined) {\n      this.environment.assignAt(distance, expr.variable.name, value)\n    } else {\n      globals.assign(expr.variable.name, value)\n    }\n\n    this.environment.assign(expr.variable.name, value)\n\n    return value\n  }\n\n  visitBinaryExpr(expr: Expr.Binary): LoxValue {\n    const op = binaryOperators[expr.operator.type]\n\n    if (op) {\n      return op(expr.operator, this.eval(expr.left), this.eval(expr.right))\n    }\n\n    throw new Error()\n  }\n\n  visitTernaryExpr(expr: Expr.Ternary): LoxValue {\n    if (isTruthy(this.eval(expr.condition))) {\n      return this.eval(expr.left)\n    }\n\n    return this.eval(expr.right)\n  }\n\n  visitLogicalExpr(expr: Expr.Logical): LoxValue {\n    const left = this.eval(expr.left)\n\n    if (expr.operator.type === TokenType.OR) {\n      if (isTruthy(left)) {\n        return left\n      }\n    } else if (!isTruthy(left)) {\n      return left\n    }\n\n    return this.eval(expr.right)\n  }\n\n  visitGroupingExpr(expr: Expr.Grouping): LoxValue {\n    return this.eval(expr.expression)\n  }\n\n  visitLiteralExpr(expr: Expr.Literal): LoxValue {\n    return expr.value\n  }\n\n  visitUnaryExpr(expr: Expr.Unary): LoxValue {\n    const op = unaryOperators[expr.operator.type]\n\n    if (op) {\n      return op(expr.operator, this.eval(expr.right))\n    }\n\n    throw new Error()\n  }\n\n  visitCallExpr(expr: Expr.Call): LoxValue {\n    const callee = this.eval(expr.callee)\n    const args = expr.args.map(a => this.eval(a))\n\n    if (!(callee instanceof Callable)) {\n      throw new RuntimeError(expr.paren, \"Can only call functions and classes\")\n    }\n\n    if (args.length !== callee.getArity()) {\n      throw new RuntimeError(\n        expr.paren,\n        `Expected ${callee.getArity()} arguments but got ${args.length}`\n      )\n    }\n\n    return callee.call(this, args)\n  }\n\n  execBlock(block: Stmt.Block, environment: Environment): LoxValue {\n    const previous = this.environment\n\n    try {\n      this.environment = environment\n\n      this.exec(block.statements)\n\n      return null\n    } finally {\n      this.environment = previous\n    }\n  }\n\n  lookUpVariable(name: Token, expr: Expr.Expr): LoxValue {\n    const distance = this.locals.get(expr)\n\n    if (distance !== undefined) {\n      return this.environment.getAt(distance, name)\n    } else {\n      return globals.get(name)\n    }\n  }\n}\n\nexport const isString = (v: LoxValue): v is string => typeof v === \"string\"\n\nexport const isNumber = (v: LoxValue): v is number => typeof v === \"number\"\n\nexport const isNil = (v: LoxValue): v is null => v === null\n\nexport const isTruthy = (v: LoxValue) => v !== null && v !== false\n\nexport const stringify = (v: LoxValue): string =>\n  isNil(v) ? \"nil\" : v.toString()\n\nconst checkOperands = <T extends LoxValue>(\n  assert: (v: LoxValue) => v is T,\n  message: string,\n  next?: Function\n) => (func: (...operands: T[]) => LoxValue) => (\n  operator: Token,\n  ...operands: LoxValue[]\n): LoxValue => {\n  if (operands.every(assert)) {\n    return func(...(operands as T[]))\n  }\n\n  if (next) {\n    return next(func)(operator, ...operands)\n  }\n\n  throw new RuntimeError(operator, message)\n}\n\nconst checkNumberOperands = checkOperands(isNumber, \"Operands must be a number\")\n\nconst numberOrStringErrorMessage = \"Operands must be two numbers or two strings\"\nconst checkNumberOrStringOperands = checkOperands(\n  isNumber,\n  numberOrStringErrorMessage,\n  checkOperands(isString, numberOrStringErrorMessage)\n)\n\ntype OperatorsMap = Partial<\n  Record<TokenType, (operator: Token, ...operands: LoxValue[]) => LoxValue>\n>\n\nconst unaryOperators: OperatorsMap = {\n  [TokenType.BANG]: (_, v) => !isTruthy(v),\n  [TokenType.MINUS]: checkNumberOperands(v => -v)\n}\n\nconst binaryPlusOperator = (op: Token, a: LoxValue, b: LoxValue): LoxValue => {\n  if (isNumber(a) && isNumber(b)) {\n    return a + b\n  }\n\n  if (isString(a) || isString(b)) {\n    return stringify(a) + stringify(b)\n  }\n\n  throw new RuntimeError(\n    op,\n    \"Operands must be two numbers or one of them must be a string\"\n  )\n}\n\nconst binarySlashOperator = (op: Token, a: LoxValue, b: LoxValue): LoxValue => {\n  if (b === 0) {\n    throw new RuntimeError(op, \"Division by zero\")\n  }\n\n  return checkNumberOperands((a, b) => a / b)(op, a, b)\n}\n\nconst binaryOperators: OperatorsMap = {\n  [TokenType.PLUS]: binaryPlusOperator,\n  [TokenType.MINUS]: checkNumberOperands((a, b) => a - b),\n  [TokenType.SLASH]: binarySlashOperator,\n  [TokenType.STAR]: checkNumberOperands((a, b) => a * b),\n\n  [TokenType.GREATER]: checkNumberOrStringOperands((a, b) => a > b),\n  [TokenType.GREATER_EQUAL]: checkNumberOrStringOperands((a, b) => a >= b),\n  [TokenType.LESS]: checkNumberOrStringOperands((a, b) => a < b),\n  [TokenType.LESS_EQUAL]: checkNumberOrStringOperands((a, b) => a <= b),\n\n  [TokenType.EQUAL_EQUAL]: (_, a, b) => a === b,\n  [TokenType.BANG_EQUAL]: (_, a, b) => a !== b\n}\n"]},"metadata":{},"sourceType":"module"}