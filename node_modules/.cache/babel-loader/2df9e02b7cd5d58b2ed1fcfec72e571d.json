{"ast":null,"code":"import { Result } from \"./common\";\nexport class ResolveError extends Error {\n  constructor(token, message) {\n    super(message);\n    this.token = token;\n    this.message = message;\n  }\n\n}\nexport class Resolver {\n  static resolve(options) {\n    const resolver = new Resolver(options.interpreter);\n    resolver.resolve(options.statements);\n\n    if (resolver.errors.length === 0) {\n      return Result.Ok(undefined);\n    }\n\n    return Result.Fail(resolver.errors);\n  }\n\n  constructor(interpreter) {\n    this.interpreter = interpreter;\n    this.scopes = [];\n    this.errors = [];\n  }\n\n  resolve(stmt) {\n    if (!Array.isArray(stmt)) {\n      return stmt.accept(this);\n    }\n\n    stmt.forEach(s => this.resolve(s));\n  }\n\n  resolveLocal(expr, name) {\n    for (let i = this.scopes.length - 1; i >= 0; i -= 1) {\n      if (this.scopes[i][name.lexeme] !== undefined) {\n        this.interpreter.resolve(expr, this.scopes.length - 1 - i);\n        return;\n      }\n    }\n  }\n\n  resolveFunction(stmt) {\n    this.beginScope();\n    stmt.params.forEach(param => {\n      this.declare(param);\n      this.define(param);\n    });\n    this.resolve(stmt.body.statements);\n    this.endScope();\n  }\n\n  beginScope() {\n    this.scopes.push({});\n  }\n\n  endScope() {\n    this.scopes.pop();\n  }\n\n  peekScope() {\n    if (this.scopes.length === 0) {\n      return;\n    }\n\n    return this.scopes[this.scopes.length - 1];\n  }\n\n  declare(name) {\n    const scope = this.peekScope();\n\n    if (!scope) {\n      return;\n    }\n\n    if (scope[name.lexeme] !== undefined) {\n      this.errors.push(new ResolveError(name, \"Variable with this name already declared in this scope\"));\n    }\n\n    scope[name.lexeme] = false;\n  }\n\n  define(name) {\n    const scope = this.peekScope();\n\n    if (!scope) {\n      return;\n    }\n\n    scope[name.lexeme] = true;\n  }\n\n  visitBlockStmt(stmt) {\n    this.beginScope();\n    this.resolve(stmt.statements);\n    this.endScope();\n  }\n\n  visitVarStmt(stmt) {\n    this.declare(stmt.variable.name);\n\n    if (stmt.initializer !== undefined) {\n      this.resolve(stmt.initializer);\n    }\n\n    this.define(stmt.variable.name);\n  }\n\n  visitVariableExpr(expr) {\n    const scope = this.peekScope();\n\n    if (scope && scope[expr.name.lexeme] === false) {\n      this.errors.push(new ResolveError(expr.name, \"Cannot read local variable in its own initializer\"));\n    }\n\n    this.resolveLocal(expr, expr.name);\n  }\n\n  visitAssignExpr(expr) {\n    this.resolve(expr.value);\n    this.resolveLocal(expr, expr.variable.name);\n  }\n\n  visitFunctionStmt(stmt) {\n    this.declare(stmt.name);\n    this.define(stmt.name);\n    this.resolveFunction(stmt);\n  }\n\n  visitExpressionStmt(stmt) {\n    this.resolve(stmt.expression);\n  }\n\n  visitIfStmt(stmt) {\n    this.resolve(stmt.condition);\n    this.resolve(stmt.thenBranch);\n\n    if (stmt.elseBranch) {\n      this.resolve(stmt.elseBranch);\n    }\n  }\n\n  visitPrintStmt(stmt) {\n    this.resolve(stmt.expression);\n  }\n\n  visitReturnStmt(stmt) {\n    if (stmt.value) {\n      this.resolve(stmt.value);\n    }\n  }\n\n  visitWhileStmt(stmt) {\n    this.resolve(stmt.condition);\n    this.resolve(stmt.body);\n  }\n\n  visitBreakStmt(stmt) {}\n\n  visitBinaryExpr(expr) {\n    this.resolve(expr.left);\n    this.resolve(expr.right);\n  }\n\n  visitCallExpr(expr) {\n    this.resolve(expr.callee);\n    expr.args.forEach(arg => this.resolve(arg));\n  }\n\n  visitGroupingExpr(expr) {\n    this.resolve(expr.expression);\n  }\n\n  visitLiteralExpr(expr) {}\n\n  visitLogicalExpr(expr) {\n    this.resolve(expr.left);\n    this.resolve(expr.right);\n  }\n\n  visitUnaryExpr(expr) {\n    this.resolve(expr.right);\n  }\n\n  visitTernaryExpr(expr) {\n    this.resolve(expr.condition);\n    this.resolve(expr.left);\n    this.resolve(expr.right);\n  }\n\n}","map":{"version":3,"sources":["/home/chriz/Documents/kame-code/src/logic/tslox/resolver.ts"],"names":["Result","ResolveError","Error","constructor","token","message","Resolver","resolve","options","resolver","interpreter","statements","errors","length","Ok","undefined","Fail","scopes","stmt","Array","isArray","accept","forEach","s","resolveLocal","expr","name","i","lexeme","resolveFunction","beginScope","params","param","declare","define","body","endScope","push","pop","peekScope","scope","visitBlockStmt","visitVarStmt","variable","initializer","visitVariableExpr","visitAssignExpr","value","visitFunctionStmt","visitExpressionStmt","expression","visitIfStmt","condition","thenBranch","elseBranch","visitPrintStmt","visitReturnStmt","visitWhileStmt","visitBreakStmt","visitBinaryExpr","left","right","visitCallExpr","callee","args","arg","visitGroupingExpr","visitLiteralExpr","visitLogicalExpr","visitUnaryExpr","visitTernaryExpr"],"mappings":"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","sourcesContent":["import * as Expr from \"./expr\"\nimport * as Stmt from \"./stmt\"\nimport { Token } from \"./token\"\nimport { Result } from \"./common\"\nimport { Interpreter } from \"./interpreter\"\n\nexport class ResolveError extends Error {\n  constructor(public token: Token, public message: string) {\n    super(message)\n  }\n}\n\nexport class Resolver implements Expr.Visitor<void>, Stmt.Visitor<void> {\n  private readonly scopes: Record<string, boolean>[] = []\n  readonly errors: ResolveError[] = []\n\n  static resolve(options: {\n    interpreter: Interpreter\n    statements: Stmt.Stmt[]\n  }): Result<void, ResolveError[]> {\n    const resolver = new Resolver(options.interpreter)\n\n    resolver.resolve(options.statements)\n\n    if (resolver.errors.length === 0) {\n      return Result.Ok(undefined)\n    }\n\n    return Result.Fail(resolver.errors)\n  }\n\n  constructor(private readonly interpreter: Interpreter) {}\n\n  private resolve(stmt: Expr.Expr | Stmt.Stmt | Stmt.Stmt[]): void\n\n  private resolve(stmt: any) {\n    if (!Array.isArray(stmt)) {\n      return stmt.accept(this)\n    }\n\n    stmt.forEach(s => this.resolve(s))\n  }\n\n  private resolveLocal(expr: Expr.Expr, name: Token) {\n    for (let i = this.scopes.length - 1; i >= 0; i -= 1) {\n      if (this.scopes[i][name.lexeme] !== undefined) {\n        this.interpreter.resolve(expr, this.scopes.length - 1 - i)\n        return\n      }\n    }\n  }\n\n  private resolveFunction(stmt: Stmt.Function) {\n    this.beginScope()\n\n    stmt.params.forEach(param => {\n      this.declare(param)\n      this.define(param)\n    })\n\n    this.resolve(stmt.body.statements)\n\n    this.endScope()\n  }\n\n  private beginScope() {\n    this.scopes.push({})\n  }\n\n  private endScope() {\n    this.scopes.pop()\n  }\n\n  private peekScope() {\n    if (this.scopes.length === 0) {\n      return\n    }\n\n    return this.scopes[this.scopes.length - 1]\n  }\n\n  private declare(name: Token) {\n    const scope = this.peekScope()\n\n    if (!scope) {\n      return\n    }\n\n    if (scope[name.lexeme] !== undefined) {\n      this.errors.push(\n        new ResolveError(\n          name,\n          \"Variable with this name already declared in this scope\"\n        )\n      )\n    }\n\n    scope[name.lexeme] = false\n  }\n\n  private define(name: Token) {\n    const scope = this.peekScope()\n\n    if (!scope) {\n      return\n    }\n\n    scope[name.lexeme] = true\n  }\n\n  visitBlockStmt(stmt: Stmt.Block) {\n    this.beginScope()\n    this.resolve(stmt.statements)\n    this.endScope()\n  }\n\n  visitVarStmt(stmt: Stmt.Var) {\n    this.declare(stmt.variable.name)\n\n    if (stmt.initializer !== undefined) {\n      this.resolve(stmt.initializer)\n    }\n\n    this.define(stmt.variable.name)\n  }\n\n  visitVariableExpr(expr: Expr.Variable) {\n    const scope = this.peekScope()\n\n    if (scope && scope[expr.name.lexeme] === false) {\n      this.errors.push(\n        new ResolveError(\n          expr.name,\n          \"Cannot read local variable in its own initializer\"\n        )\n      )\n    }\n\n    this.resolveLocal(expr, expr.name)\n  }\n\n  visitAssignExpr(expr: Expr.Assign) {\n    this.resolve(expr.value)\n    this.resolveLocal(expr, expr.variable.name)\n  }\n\n  visitFunctionStmt(stmt: Stmt.Function) {\n    this.declare(stmt.name)\n    this.define(stmt.name)\n\n    this.resolveFunction(stmt)\n  }\n\n  visitExpressionStmt(stmt: Stmt.Expression) {\n    this.resolve(stmt.expression)\n  }\n\n  visitIfStmt(stmt: Stmt.If) {\n    this.resolve(stmt.condition)\n    this.resolve(stmt.thenBranch)\n\n    if (stmt.elseBranch) {\n      this.resolve(stmt.elseBranch)\n    }\n  }\n\n  visitPrintStmt(stmt: Stmt.Print) {\n    this.resolve(stmt.expression)\n  }\n\n  visitReturnStmt(stmt: Stmt.Return) {\n    if (stmt.value) {\n      this.resolve(stmt.value)\n    }\n  }\n\n  visitWhileStmt(stmt: Stmt.While) {\n    this.resolve(stmt.condition)\n    this.resolve(stmt.body)\n  }\n\n  visitBreakStmt(stmt: Stmt.Break) {}\n\n  visitBinaryExpr(expr: Expr.Binary) {\n    this.resolve(expr.left)\n    this.resolve(expr.right)\n  }\n\n  visitCallExpr(expr: Expr.Call) {\n    this.resolve(expr.callee)\n\n    expr.args.forEach(arg => this.resolve(arg))\n  }\n\n  visitGroupingExpr(expr: Expr.Grouping) {\n    this.resolve(expr.expression)\n  }\n\n  visitLiteralExpr(expr: Expr.Literal) {}\n\n  visitLogicalExpr(expr: Expr.Logical) {\n    this.resolve(expr.left)\n    this.resolve(expr.right)\n  }\n\n  visitUnaryExpr(expr: Expr.Unary) {\n    this.resolve(expr.right)\n  }\n\n  visitTernaryExpr(expr: Expr.Ternary) {\n    this.resolve(expr.condition)\n    this.resolve(expr.left)\n    this.resolve(expr.right)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}