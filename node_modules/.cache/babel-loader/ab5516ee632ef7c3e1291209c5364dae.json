{"ast":null,"code":"export class AstPrinter {\n  constructor() {\n    this.depth = -1;\n  }\n\n  static print(statements) {\n    const printer = new AstPrinter();\n    return statements.map(s => printer.print(s)).join(\"\\n\");\n  }\n\n  print(expr) {\n    return expr.accept(this);\n  }\n\n  parenthesize(name, ...exprs) {\n    this.depth += 1;\n\n    try {\n      return exprs.reduce((str, expr) => str + \" \" + expr.accept(this), \"\\n\" + \" \".repeat(this.depth * 2) + \"(\" + name) + \")\";\n    } finally {\n      this.depth -= 1;\n    }\n  }\n\n  visitExpressionStmt(stmt) {\n    return this.print(stmt.expression);\n  }\n\n  visitPrintStmt(stmt) {\n    return this.parenthesize(\"print\", stmt.expression);\n  }\n\n  visitVarStmt(stmt) {\n    const exprs = [stmt.variable];\n\n    if (stmt.initializer) {\n      exprs.push(stmt.initializer);\n    }\n\n    return this.parenthesize(\"define\", ...exprs);\n  }\n\n  visitFunctionStmt(stmt) {\n    return this.parenthesize(`define (${stmt.name.lexeme} ${stmt.params.map(p => p.lexeme).join(\" \")})`, stmt.body);\n  }\n\n  visitBlockStmt(stmt) {\n    return this.parenthesize(\"block\", ...stmt.statements);\n  }\n\n  visitIfStmt(stmt) {\n    const statements = [stmt.thenBranch];\n\n    if (stmt.elseBranch) {\n      statements.push(stmt.elseBranch);\n    }\n\n    return this.parenthesize(\"if\" + (stmt.elseBranch ? \"Else\" : \"\"), stmt.condition, ...statements);\n  }\n\n  visitWhileStmt(stmt) {\n    return this.parenthesize(\"while\", stmt.condition, stmt.body);\n  }\n\n  visitBreakStmt(_stmt) {\n    return this.parenthesize(\"break\");\n  }\n\n  visitReturnStmt(stmt) {\n    const exprs = [];\n\n    if (stmt.value) {\n      exprs.push(stmt.value);\n    }\n\n    return this.parenthesize(\"return\", ...exprs);\n  }\n\n  visitBinaryExpr(expr) {\n    return this.parenthesize(expr.operator.lexeme, expr.left, expr.right);\n  }\n\n  visitLogicalExpr(expr) {\n    return this.parenthesize(expr.operator.lexeme, expr.left, expr.right);\n  }\n\n  visitTernaryExpr(expr) {\n    return this.parenthesize(\"ifElse\", expr.condition, expr.left, expr.right);\n  }\n\n  visitGroupingExpr(expr) {\n    return this.parenthesize(\"group\", expr.expression);\n  }\n\n  visitLiteralExpr(expr) {\n    if (expr.value === null) {\n      return \"nil\";\n    }\n\n    if (typeof expr.value === \"string\") {\n      return `\"${expr.value}\"`;\n    }\n\n    return expr.value.toString();\n  }\n\n  visitUnaryExpr(expr) {\n    return this.parenthesize(expr.operator.lexeme, expr.right);\n  }\n\n  visitVariableExpr(expr) {\n    return expr.name.lexeme;\n  }\n\n  visitAssignExpr(expr) {\n    return this.parenthesize(\"set\", expr.variable, expr.value);\n  }\n\n  visitCallExpr(expr) {\n    return this.parenthesize(expr.callee.accept(this), ...expr.args);\n  }\n\n}","map":{"version":3,"sources":["/home/chriz/Documents/kame-code/src/logic/tslox/ast-printer.ts"],"names":["AstPrinter","depth","print","statements","printer","map","s","join","expr","accept","parenthesize","name","exprs","reduce","str","repeat","visitExpressionStmt","stmt","expression","visitPrintStmt","visitVarStmt","variable","initializer","push","visitFunctionStmt","lexeme","params","p","body","visitBlockStmt","visitIfStmt","thenBranch","elseBranch","condition","visitWhileStmt","visitBreakStmt","_stmt","visitReturnStmt","value","visitBinaryExpr","operator","left","right","visitLogicalExpr","visitTernaryExpr","visitGroupingExpr","visitLiteralExpr","toString","visitUnaryExpr","visitVariableExpr","visitAssignExpr","visitCallExpr","callee","args"],"mappings":"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","sourcesContent":["import * as Expr from \"./expr\"\nimport * as Stmt from \"./stmt\"\n\nexport class AstPrinter implements Expr.Visitor<string>, Stmt.Visitor<string> {\n  static print(statements: Stmt.Stmt[]): string {\n    const printer = new AstPrinter()\n\n    return statements.map(s => printer.print(s)).join(\"\\n\")\n  }\n\n  print(stmt: Stmt.Stmt): string\n  print(expr: Expr.Expr): string\n\n  print(expr: any): string {\n    return expr.accept(this)\n  }\n\n  private depth = -1\n\n  private parenthesize(\n    name: string,\n    ...exprs: (Stmt.Stmt | Expr.Expr)[]\n  ): string\n\n  private parenthesize(name: string, ...exprs: any[]): string {\n    this.depth += 1\n    try {\n      return (\n        exprs.reduce(\n          (str, expr) => str + \" \" + expr.accept(this),\n          \"\\n\" + \" \".repeat(this.depth * 2) + \"(\" + name\n        ) + \")\"\n      )\n    } finally {\n      this.depth -= 1\n    }\n  }\n\n  visitExpressionStmt(stmt: Stmt.Expression): string {\n    return this.print(stmt.expression)\n  }\n\n  visitPrintStmt(stmt: Stmt.Print): string {\n    return this.parenthesize(\"print\", stmt.expression)\n  }\n\n  visitVarStmt(stmt: Stmt.Var): string {\n    const exprs: Expr.Expr[] = [stmt.variable]\n\n    if (stmt.initializer) {\n      exprs.push(stmt.initializer)\n    }\n\n    return this.parenthesize(\"define\", ...exprs)\n  }\n\n  visitFunctionStmt(stmt: Stmt.Function): string {\n    return this.parenthesize(\n      `define (${stmt.name.lexeme} ${stmt.params\n        .map(p => p.lexeme)\n        .join(\" \")})`,\n      stmt.body\n    )\n  }\n\n  visitBlockStmt(stmt: Stmt.Block): string {\n    return this.parenthesize(\"block\", ...stmt.statements)\n  }\n\n  visitIfStmt(stmt: Stmt.If): string {\n    const statements = [stmt.thenBranch]\n\n    if (stmt.elseBranch) {\n      statements.push(stmt.elseBranch)\n    }\n\n    return this.parenthesize(\n      \"if\" + (stmt.elseBranch ? \"Else\" : \"\"),\n      stmt.condition,\n      ...statements\n    )\n  }\n\n  visitWhileStmt(stmt: Stmt.While): string {\n    return this.parenthesize(\"while\", stmt.condition, stmt.body)\n  }\n\n  visitBreakStmt(_stmt: Stmt.Break): string {\n    return this.parenthesize(\"break\")\n  }\n\n  visitReturnStmt(stmt: Stmt.Return): string {\n    const exprs: Expr.Expr[] = []\n\n    if (stmt.value) {\n      exprs.push(stmt.value)\n    }\n\n    return this.parenthesize(\"return\", ...exprs)\n  }\n\n  visitBinaryExpr(expr: Expr.Binary): string {\n    return this.parenthesize(expr.operator.lexeme, expr.left, expr.right)\n  }\n\n  visitLogicalExpr(expr: Expr.Logical): string {\n    return this.parenthesize(expr.operator.lexeme, expr.left, expr.right)\n  }\n\n  visitTernaryExpr(expr: Expr.Ternary): string {\n    return this.parenthesize(\"ifElse\", expr.condition, expr.left, expr.right)\n  }\n\n  visitGroupingExpr(expr: Expr.Grouping): string {\n    return this.parenthesize(\"group\", expr.expression)\n  }\n\n  visitLiteralExpr(expr: Expr.Literal): string {\n    if (expr.value === null) {\n      return \"nil\"\n    }\n\n    if (typeof expr.value === \"string\") {\n      return `\"${expr.value}\"`\n    }\n\n    return expr.value.toString()\n  }\n\n  visitUnaryExpr(expr: Expr.Unary): string {\n    return this.parenthesize(expr.operator.lexeme, expr.right)\n  }\n\n  visitVariableExpr(expr: Expr.Variable): string {\n    return expr.name.lexeme\n  }\n\n  visitAssignExpr(expr: Expr.Assign): string {\n    return this.parenthesize(\"set\", expr.variable, expr.value)\n  }\n\n  visitCallExpr(expr: Expr.Call): string {\n    return this.parenthesize(expr.callee.accept(this), ...expr.args)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}