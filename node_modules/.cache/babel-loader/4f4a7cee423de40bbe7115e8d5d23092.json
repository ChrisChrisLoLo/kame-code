{"ast":null,"code":"import { TokenType } from \"./token-type\";\nimport { Result } from \"./common\";\nimport * as Expr from \"./expr\";\nimport * as Stmt from \"./stmt\";\nconst MAX_ARGUMENTS_COUNT = 255;\nconst MAX_PARAMETERS_COUNT = 8;\nexport class ParseError extends Error {\n  constructor(token, message) {\n    super(message);\n    this.token = token;\n    this.message = message;\n  }\n\n}\nexport class Parser {\n  constructor(tokens) {\n    this.tokens = void 0;\n    this.current = 0;\n    this.errors = [];\n    this.context = new Context();\n\n    this.binary = (operation, ...types) => () => {\n      let expr = operation();\n\n      while (this.match(...types)) {\n        const op = this.previous();\n        const right = operation();\n        expr = new Expr.Binary(expr, op, right);\n      }\n\n      return expr;\n    };\n\n    this.unary = () => {\n      if (this.match(TokenType.BANG, TokenType.MINUS)) {\n        return new Expr.Unary(this.previous(), this.unary());\n      }\n\n      return this.call();\n    };\n\n    this.multiplication = this.binary(this.unary, TokenType.SLASH, TokenType.STAR);\n    this.addition = this.binary(this.multiplication, TokenType.PLUS, TokenType.MINUS);\n    this.comparison = this.binary(this.addition, TokenType.GREATER, TokenType.GREATER_EQUAL, TokenType.LESS, TokenType.LESS_EQUAL);\n    this.equality = this.binary(this.comparison, TokenType.BANG_EQUAL, TokenType.EQUAL_EQUAL);\n\n    if (tokens.length === 0) {\n      throw new Error(\"Expected non-empty array of tokens\");\n    }\n\n    this.tokens = tokens;\n  }\n\n  static parse(tokens) {\n    return new Parser(tokens).parse();\n  }\n\n  parse() {\n    const statements = [];\n\n    while (!this.isAtEnd()) {\n      try {\n        statements.push(this.declaration());\n      } catch (error) {\n        this.errors.push(error);\n        this.synchronize();\n      }\n    }\n\n    if (this.errors.length === 0) {\n      return Result.Ok(statements);\n    }\n\n    return Result.Fail(this.errors);\n  }\n\n  primary() {\n    if (this.match(TokenType.FALSE)) return new Expr.Literal(false);\n    if (this.match(TokenType.TRUE)) return new Expr.Literal(true);\n    if (this.match(TokenType.NIL)) return new Expr.Literal(null);\n\n    if (this.match(TokenType.NUMBER, TokenType.STRING)) {\n      return new Expr.Literal(this.previous().literal);\n    }\n\n    if (this.match(TokenType.IDENTIFIER)) {\n      return new Expr.Variable(this.previous());\n    }\n\n    this.consume(TokenType.LEFT_PAREN, \"Expected expression\");\n    const expr = this.expression();\n    this.consume(TokenType.RIGHT_PAREN, \"Expected ')' after expression\");\n    return new Expr.Grouping(expr);\n  }\n\n  call() {\n    let expr = this.primary();\n\n    while (this.match(TokenType.LEFT_PAREN)) {\n      const args = [];\n\n      if (!this.check(TokenType.RIGHT_PAREN)) {\n        do {\n          if (args.length >= MAX_ARGUMENTS_COUNT) {\n            this.errors.push(new ParseError(this.peek(), `Cannot have more than ${MAX_ARGUMENTS_COUNT} arguments`));\n          }\n\n          args.push(this.expression());\n        } while (this.match(TokenType.COMMA));\n      }\n\n      const paren = this.consume(TokenType.RIGHT_PAREN, \"Expected ')' after arguments\");\n      expr = new Expr.Call(expr, paren, args);\n    }\n\n    return expr;\n  }\n\n  logical() {\n    let expr = this.equality();\n\n    while (this.match(TokenType.OR, TokenType.AND)) {\n      const op = this.previous();\n      const right = this.equality();\n      expr = new Expr.Logical(expr, op, right);\n    }\n\n    return expr;\n  }\n\n  ternary() {\n    let expr = this.logical();\n\n    if (this.match(TokenType.QUESTION)) {\n      const left = this.logical();\n      this.consume(TokenType.COLON, \"Expected ':' in ternary expression\");\n      const right = this.ternary();\n      expr = new Expr.Ternary(expr, left, right);\n    }\n\n    return expr;\n  }\n\n  assignment() {\n    const expr = this.ternary();\n\n    if (this.match(TokenType.EQUAL)) {\n      const op = this.previous();\n      const value = this.assignment();\n\n      if (expr instanceof Expr.Variable) {\n        return new Expr.Assign(expr, value);\n      }\n\n      throw new ParseError(op, \"Invalid assignment target\");\n    }\n\n    return expr;\n  }\n\n  expression() {\n    return this.assignment();\n  }\n\n  statement() {\n    if (this.match(TokenType.IF)) {\n      return this.ifStatement();\n    }\n\n    if (this.match(TokenType.WHILE)) {\n      return this.whileStatement();\n    }\n\n    if (this.match(TokenType.FOR)) {\n      return this.forStatement();\n    }\n\n    if (this.match(TokenType.BREAK)) {\n      return this.breakStatement();\n    }\n\n    if (this.match(TokenType.RETURN)) {\n      return this.returnStatement();\n    }\n\n    if (this.match(TokenType.PRINT)) {\n      return this.printStatement();\n    }\n\n    if (this.match(TokenType.LEFT_BRACE)) {\n      return this.blockStatement();\n    }\n\n    return this.expressionStatement();\n  }\n\n  printStatement() {\n    const expr = this.expression();\n    this.consume(TokenType.SEMICOLON, \"Expected ';' after print statement\");\n    return new Stmt.Print(expr);\n  }\n\n  expressionStatement() {\n    const expr = this.expression();\n    this.consume(TokenType.SEMICOLON, \"Expected ';' after expression\");\n    return new Stmt.Expression(expr);\n  }\n\n  blockStatement() {\n    const statements = [];\n\n    while (!this.check(TokenType.RIGHT_BRACE) && !this.isAtEnd()) {\n      statements.push(this.declaration());\n    }\n\n    this.consume(TokenType.RIGHT_BRACE, \"Expected '}' after block\");\n    return new Stmt.Block(statements);\n  }\n\n  ifStatement() {\n    this.consume(TokenType.LEFT_PAREN, \"Expected '(' after 'if'\");\n    const condition = this.expression();\n    this.consume(TokenType.RIGHT_PAREN, \"Expected ')' after 'if' condition\");\n    const thenBranch = this.statement();\n    const elseBranch = this.match(TokenType.ELSE) ? this.statement() : undefined;\n    return new Stmt.If(condition, thenBranch, elseBranch);\n  }\n\n  whileStatement() {\n    this.consume(TokenType.LEFT_PAREN, \"Expected '(' after 'while'\");\n    const condition = this.expression();\n    this.consume(TokenType.RIGHT_PAREN, \"Expected ')' after 'while' condition\");\n    const body = this.withContext(ContextType.LOOP_BODY, () => this.statement());\n    return new Stmt.While(condition, body);\n  }\n\n  forStatement() {\n    this.consume(TokenType.LEFT_PAREN, \"Expected '(' after 'for'\");\n    let initializer;\n\n    if (this.match(TokenType.SEMICOLON)) {\n      initializer = undefined;\n    } else if (this.match(TokenType.VAR)) {\n      initializer = this.varDeclaration();\n    } else {\n      initializer = this.expressionStatement();\n    }\n\n    let condition;\n\n    if (this.match(TokenType.SEMICOLON)) {\n      condition = new Expr.Literal(true);\n    } else {\n      condition = this.expression();\n      this.consume(TokenType.SEMICOLON, \"Expected ';' after 'for' condition\");\n    }\n\n    let increment;\n\n    if (this.match(TokenType.RIGHT_PAREN)) {\n      increment = undefined;\n    } else {\n      increment = this.expression();\n      this.consume(TokenType.RIGHT_PAREN, \"Expected ')' after 'for' clauses\");\n    }\n\n    let body = this.withContext(ContextType.LOOP_BODY, () => this.statement());\n\n    if (increment) {\n      body = new Stmt.Block([body, new Stmt.Expression(increment)]);\n    }\n\n    body = new Stmt.While(condition, body);\n\n    if (initializer) {\n      body = new Stmt.Block([initializer, body]);\n    }\n\n    return body;\n  }\n\n  breakStatement() {\n    if (!this.context.check(ContextType.LOOP_BODY)) {\n      throw new ParseError(this.previous(), \"Unexpected 'break' statement outside of loop body\");\n    }\n\n    this.consume(TokenType.SEMICOLON, \"Expected ';' after 'break' statement\");\n    return new Stmt.Break();\n  }\n\n  returnStatement() {\n    const value = this.check(TokenType.SEMICOLON) ? undefined : this.expression();\n    this.consume(TokenType.SEMICOLON, \"Expected ';' after 'return' statement\");\n    return new Stmt.Return(this.previous(), value);\n  }\n\n  declaration() {\n    if (this.match(TokenType.VAR)) {\n      return this.varDeclaration();\n    }\n\n    if (this.match(TokenType.FUN)) {\n      return this.function(\"function\");\n    }\n\n    return this.statement();\n  }\n\n  varDeclaration() {\n    const name = this.consume(TokenType.IDENTIFIER, \"Expected variable name\");\n    const initializer = this.match(TokenType.EQUAL) ? this.expression() : undefined;\n    this.consume(TokenType.SEMICOLON, \"Expected ';' after variable declaration\");\n    return new Stmt.Var(new Expr.Variable(name), initializer);\n  }\n\n  function(kind) {\n    const name = this.consume(TokenType.IDENTIFIER, `Expected ${kind} name`);\n    const params = [];\n    this.consume(TokenType.LEFT_PAREN, `Expected '(' after ${kind} name`);\n\n    if (!this.check(TokenType.RIGHT_PAREN)) {\n      do {\n        if (params.length >= MAX_PARAMETERS_COUNT) {\n          this.errors.push(new ParseError(this.peek(), `Cannot have more than ${MAX_PARAMETERS_COUNT} parameters`));\n        }\n\n        params.push(this.consume(TokenType.IDENTIFIER, \"Expected parameter name\"));\n      } while (this.match(TokenType.COMMA));\n    }\n\n    this.consume(TokenType.RIGHT_PAREN, \"Expected ')' after parameters\");\n    this.consume(TokenType.LEFT_BRACE, `Expected '{' before ${kind} body`);\n    const body = this.blockStatement();\n    return new Stmt.Function(name, params, body);\n  }\n\n  withContext(type, cb) {\n    this.context.push(type);\n\n    try {\n      return cb();\n    } finally {\n      this.context.pop(type);\n    }\n  }\n\n  synchronize() {\n    this.advance();\n\n    while (!this.isAtEnd()) {\n      if (this.previous().type === TokenType.SEMICOLON) return;\n\n      switch (this.peek().type) {\n        case TokenType.CLASS:\n        case TokenType.FUN:\n        case TokenType.VAR:\n        case TokenType.FOR:\n        case TokenType.IF:\n        case TokenType.WHILE:\n        case TokenType.PRINT:\n        case TokenType.RETURN:\n          return;\n      }\n\n      this.advance();\n    }\n  }\n\n  consume(type, message) {\n    if (this.check(type)) {\n      return this.advance();\n    }\n\n    throw new ParseError(this.peek(), message);\n  }\n\n  match(...types) {\n    for (let type of types) {\n      if (this.check(type)) {\n        this.advance();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  check(type) {\n    return !this.isAtEnd() && this.peek().type === type;\n  }\n\n  advance() {\n    if (!this.isAtEnd()) {\n      this.current += 1;\n    }\n\n    return this.previous();\n  }\n\n  peek() {\n    return this.tokens[this.current];\n  }\n\n  previous() {\n    return this.tokens[this.current - 1];\n  }\n\n  isAtEnd() {\n    return this.peek().type === TokenType.EOF;\n  }\n\n}\nvar ContextType;\n\n(function (ContextType) {\n  ContextType[ContextType[\"LOOP_BODY\"] = 0] = \"LOOP_BODY\";\n})(ContextType || (ContextType = {}));\n\nexport class Context {\n  constructor() {\n    this.map = new Map();\n  }\n\n  push(type) {\n    const ctx = this.map.get(type);\n\n    if (ctx) {\n      ctx.push(true);\n    } else {\n      this.map.set(type, [true]);\n    }\n  }\n\n  pop(type) {\n    const ctx = this.map.get(type);\n\n    if (!ctx) {\n      throw new Error(\"Context was not entered\");\n    }\n\n    ctx.pop();\n  }\n\n  check(type) {\n    const ctx = this.map.get(type);\n    return !!ctx && ctx.length > 0;\n  }\n\n}","map":{"version":3,"sources":["/home/chriz/Documents/kame-code/src/logic/tslox/parser.ts"],"names":["TokenType","Result","Expr","Stmt","MAX_ARGUMENTS_COUNT","MAX_PARAMETERS_COUNT","ParseError","Error","constructor","token","message","Parser","tokens","current","errors","context","Context","binary","operation","types","expr","match","op","previous","right","Binary","unary","BANG","MINUS","Unary","call","multiplication","SLASH","STAR","addition","PLUS","comparison","GREATER","GREATER_EQUAL","LESS","LESS_EQUAL","equality","BANG_EQUAL","EQUAL_EQUAL","length","parse","statements","isAtEnd","push","declaration","error","synchronize","Ok","Fail","primary","FALSE","Literal","TRUE","NIL","NUMBER","STRING","literal","IDENTIFIER","Variable","consume","LEFT_PAREN","expression","RIGHT_PAREN","Grouping","args","check","peek","COMMA","paren","Call","logical","OR","AND","Logical","ternary","QUESTION","left","COLON","Ternary","assignment","EQUAL","value","Assign","statement","IF","ifStatement","WHILE","whileStatement","FOR","forStatement","BREAK","breakStatement","RETURN","returnStatement","PRINT","printStatement","LEFT_BRACE","blockStatement","expressionStatement","SEMICOLON","Print","Expression","RIGHT_BRACE","Block","condition","thenBranch","elseBranch","ELSE","undefined","If","body","withContext","ContextType","LOOP_BODY","While","initializer","VAR","varDeclaration","increment","Break","Return","FUN","function","name","Var","kind","params","Function","type","cb","pop","advance","CLASS","EOF","map","Map","ctx","get","set"],"mappings":"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","sourcesContent":["import { Token } from \"./token\"\nimport { TokenType } from \"./token-type\"\nimport { Result } from \"./common\"\nimport * as Expr from \"./expr\"\nimport * as Stmt from \"./stmt\"\n\nconst MAX_ARGUMENTS_COUNT = 255\nconst MAX_PARAMETERS_COUNT = 8\n\nexport class ParseError extends Error {\n  constructor(public token: Token, public message: string) {\n    super(message)\n  }\n}\n\nexport class Parser {\n  private tokens: Token[]\n  private current: number = 0\n  private errors: ParseError[] = []\n  private context: Context = new Context()\n\n  constructor(tokens: Token[]) {\n    if (tokens.length === 0) {\n      throw new Error(\"Expected non-empty array of tokens\")\n    }\n\n    this.tokens = tokens\n  }\n\n  static parse(tokens: Token[]) {\n    return new Parser(tokens).parse()\n  }\n\n  parse(): Result<Stmt.Stmt[], ParseError[]> {\n    const statements = []\n\n    while (!this.isAtEnd()) {\n      try {\n        statements.push(this.declaration())\n      } catch (error) {\n        this.errors.push(error)\n        this.synchronize()\n      }\n    }\n\n    if (this.errors.length === 0) {\n      return Result.Ok(statements)\n    }\n\n    return Result.Fail(this.errors)\n  }\n\n  private binary = (\n    operation: () => Expr.Expr,\n    ...types: TokenType[]\n  ) => () => {\n    let expr = operation()\n\n    while (this.match(...types)) {\n      const op = this.previous()\n      const right = operation()\n\n      expr = new Expr.Binary(expr, op, right)\n    }\n\n    return expr\n  }\n\n  private primary(): Expr.Expr {\n    if (this.match(TokenType.FALSE)) return new Expr.Literal(false)\n    if (this.match(TokenType.TRUE)) return new Expr.Literal(true)\n    if (this.match(TokenType.NIL)) return new Expr.Literal(null)\n\n    if (this.match(TokenType.NUMBER, TokenType.STRING)) {\n      return new Expr.Literal(this.previous().literal)\n    }\n\n    if (this.match(TokenType.IDENTIFIER)) {\n      return new Expr.Variable(this.previous())\n    }\n\n    this.consume(TokenType.LEFT_PAREN, \"Expected expression\")\n    const expr = this.expression()\n    this.consume(TokenType.RIGHT_PAREN, \"Expected ')' after expression\")\n\n    return new Expr.Grouping(expr)\n  }\n\n  private call(): Expr.Expr {\n    let expr = this.primary()\n\n    while (this.match(TokenType.LEFT_PAREN)) {\n      const args: Expr.Expr[] = []\n\n      if (!this.check(TokenType.RIGHT_PAREN)) {\n        do {\n          if (args.length >= MAX_ARGUMENTS_COUNT) {\n            this.errors.push(\n              new ParseError(\n                this.peek(),\n                `Cannot have more than ${MAX_ARGUMENTS_COUNT} arguments`\n              )\n            )\n          }\n\n          args.push(this.expression())\n        } while (this.match(TokenType.COMMA))\n      }\n\n      const paren = this.consume(\n        TokenType.RIGHT_PAREN,\n        \"Expected ')' after arguments\"\n      )\n\n      expr = new Expr.Call(expr, paren, args)\n    }\n\n    return expr\n  }\n\n  private unary: () => Expr.Expr = () => {\n    if (this.match(TokenType.BANG, TokenType.MINUS)) {\n      return new Expr.Unary(this.previous(), this.unary())\n    }\n\n    return this.call()\n  }\n\n  private multiplication = this.binary(\n    this.unary,\n    TokenType.SLASH,\n    TokenType.STAR\n  )\n\n  private addition = this.binary(\n    this.multiplication,\n    TokenType.PLUS,\n    TokenType.MINUS\n  )\n\n  private comparison = this.binary(\n    this.addition,\n    TokenType.GREATER,\n    TokenType.GREATER_EQUAL,\n    TokenType.LESS,\n    TokenType.LESS_EQUAL\n  )\n\n  private equality = this.binary(\n    this.comparison,\n    TokenType.BANG_EQUAL,\n    TokenType.EQUAL_EQUAL\n  )\n\n  private logical(): Expr.Expr {\n    let expr = this.equality()\n\n    while (this.match(TokenType.OR, TokenType.AND)) {\n      const op = this.previous()\n      const right = this.equality()\n\n      expr = new Expr.Logical(expr, op, right)\n    }\n\n    return expr\n  }\n\n  private ternary(): Expr.Expr {\n    let expr = this.logical()\n\n    if (this.match(TokenType.QUESTION)) {\n      const left = this.logical()\n      this.consume(TokenType.COLON, \"Expected ':' in ternary expression\")\n      const right = this.ternary()\n\n      expr = new Expr.Ternary(expr, left, right)\n    }\n\n    return expr\n  }\n\n  private assignment(): Expr.Expr {\n    const expr = this.ternary()\n\n    if (this.match(TokenType.EQUAL)) {\n      const op = this.previous()\n      const value = this.assignment()\n\n      if (expr instanceof Expr.Variable) {\n        return new Expr.Assign(expr, value)\n      }\n\n      throw new ParseError(op, \"Invalid assignment target\")\n    }\n\n    return expr\n  }\n\n  private expression(): Expr.Expr {\n    return this.assignment()\n  }\n\n  private statement(): Stmt.Stmt {\n    if (this.match(TokenType.IF)) {\n      return this.ifStatement()\n    }\n\n    if (this.match(TokenType.WHILE)) {\n      return this.whileStatement()\n    }\n\n    if (this.match(TokenType.FOR)) {\n      return this.forStatement()\n    }\n\n    if (this.match(TokenType.BREAK)) {\n      return this.breakStatement()\n    }\n\n    if (this.match(TokenType.RETURN)) {\n      return this.returnStatement()\n    }\n\n    if (this.match(TokenType.PRINT)) {\n      return this.printStatement()\n    }\n\n    if (this.match(TokenType.LEFT_BRACE)) {\n      return this.blockStatement()\n    }\n\n    return this.expressionStatement()\n  }\n\n  private printStatement(): Stmt.Print {\n    const expr = this.expression()\n    this.consume(TokenType.SEMICOLON, \"Expected ';' after print statement\")\n    return new Stmt.Print(expr)\n  }\n\n  private expressionStatement(): Stmt.Expression {\n    const expr = this.expression()\n    this.consume(TokenType.SEMICOLON, \"Expected ';' after expression\")\n    return new Stmt.Expression(expr)\n  }\n\n  private blockStatement(): Stmt.Block {\n    const statements = []\n\n    while (!this.check(TokenType.RIGHT_BRACE) && !this.isAtEnd()) {\n      statements.push(this.declaration())\n    }\n\n    this.consume(TokenType.RIGHT_BRACE, \"Expected '}' after block\")\n\n    return new Stmt.Block(statements)\n  }\n\n  private ifStatement(): Stmt.If {\n    this.consume(TokenType.LEFT_PAREN, \"Expected '(' after 'if'\")\n    const condition = this.expression()\n    this.consume(TokenType.RIGHT_PAREN, \"Expected ')' after 'if' condition\")\n\n    const thenBranch = this.statement()\n    const elseBranch = this.match(TokenType.ELSE) ? this.statement() : undefined\n\n    return new Stmt.If(condition, thenBranch, elseBranch)\n  }\n\n  private whileStatement(): Stmt.While {\n    this.consume(TokenType.LEFT_PAREN, \"Expected '(' after 'while'\")\n    const condition = this.expression()\n    this.consume(TokenType.RIGHT_PAREN, \"Expected ')' after 'while' condition\")\n\n    const body = this.withContext(ContextType.LOOP_BODY, () => this.statement())\n\n    return new Stmt.While(condition, body)\n  }\n\n  private forStatement(): Stmt.Stmt {\n    this.consume(TokenType.LEFT_PAREN, \"Expected '(' after 'for'\")\n\n    let initializer\n\n    if (this.match(TokenType.SEMICOLON)) {\n      initializer = undefined\n    } else if (this.match(TokenType.VAR)) {\n      initializer = this.varDeclaration()\n    } else {\n      initializer = this.expressionStatement()\n    }\n\n    let condition\n\n    if (this.match(TokenType.SEMICOLON)) {\n      condition = new Expr.Literal(true)\n    } else {\n      condition = this.expression()\n      this.consume(TokenType.SEMICOLON, \"Expected ';' after 'for' condition\")\n    }\n\n    let increment\n\n    if (this.match(TokenType.RIGHT_PAREN)) {\n      increment = undefined\n    } else {\n      increment = this.expression()\n      this.consume(TokenType.RIGHT_PAREN, \"Expected ')' after 'for' clauses\")\n    }\n\n    let body = this.withContext(ContextType.LOOP_BODY, () => this.statement())\n\n    if (increment) {\n      body = new Stmt.Block([body, new Stmt.Expression(increment)])\n    }\n\n    body = new Stmt.While(condition, body)\n\n    if (initializer) {\n      body = new Stmt.Block([initializer, body])\n    }\n\n    return body\n  }\n\n  private breakStatement(): Stmt.Stmt {\n    if (!this.context.check(ContextType.LOOP_BODY)) {\n      throw new ParseError(\n        this.previous(),\n        \"Unexpected 'break' statement outside of loop body\"\n      )\n    }\n\n    this.consume(TokenType.SEMICOLON, \"Expected ';' after 'break' statement\")\n\n    return new Stmt.Break()\n  }\n\n  private returnStatement(): Stmt.Stmt {\n    const value = this.check(TokenType.SEMICOLON)\n      ? undefined\n      : this.expression()\n\n    this.consume(TokenType.SEMICOLON, \"Expected ';' after 'return' statement\")\n\n    return new Stmt.Return(this.previous(), value)\n  }\n\n  private declaration(): Stmt.Stmt {\n    if (this.match(TokenType.VAR)) {\n      return this.varDeclaration()\n    }\n\n    if (this.match(TokenType.FUN)) {\n      return this.function(\"function\")\n    }\n\n    return this.statement()\n  }\n\n  private varDeclaration(): Stmt.Var {\n    const name = this.consume(TokenType.IDENTIFIER, \"Expected variable name\")\n    const initializer = this.match(TokenType.EQUAL)\n      ? this.expression()\n      : undefined\n\n    this.consume(TokenType.SEMICOLON, \"Expected ';' after variable declaration\")\n    return new Stmt.Var(new Expr.Variable(name), initializer)\n  }\n\n  private function(kind: string): Stmt.Stmt {\n    const name = this.consume(TokenType.IDENTIFIER, `Expected ${kind} name`)\n    const params = []\n\n    this.consume(TokenType.LEFT_PAREN, `Expected '(' after ${kind} name`)\n\n    if (!this.check(TokenType.RIGHT_PAREN)) {\n      do {\n        if (params.length >= MAX_PARAMETERS_COUNT) {\n          this.errors.push(\n            new ParseError(\n              this.peek(),\n              `Cannot have more than ${MAX_PARAMETERS_COUNT} parameters`\n            )\n          )\n        }\n\n        params.push(\n          this.consume(TokenType.IDENTIFIER, \"Expected parameter name\")\n        )\n      } while (this.match(TokenType.COMMA))\n    }\n\n    this.consume(TokenType.RIGHT_PAREN, \"Expected ')' after parameters\")\n    this.consume(TokenType.LEFT_BRACE, `Expected '{' before ${kind} body`)\n\n    const body = this.blockStatement()\n\n    return new Stmt.Function(name, params, body)\n  }\n\n  private withContext<T>(type: ContextType, cb: () => T): T {\n    this.context.push(type)\n\n    try {\n      return cb()\n    } finally {\n      this.context.pop(type)\n    }\n  }\n\n  private synchronize(): void {\n    this.advance()\n\n    while (!this.isAtEnd()) {\n      if (this.previous().type === TokenType.SEMICOLON) return\n\n      switch (this.peek().type) {\n        case TokenType.CLASS:\n        case TokenType.FUN:\n        case TokenType.VAR:\n        case TokenType.FOR:\n        case TokenType.IF:\n        case TokenType.WHILE:\n        case TokenType.PRINT:\n        case TokenType.RETURN:\n          return\n      }\n\n      this.advance()\n    }\n  }\n\n  private consume(type: TokenType, message: string): Token {\n    if (this.check(type)) {\n      return this.advance()\n    }\n\n    throw new ParseError(this.peek(), message)\n  }\n\n  private match(...types: TokenType[]): boolean {\n    for (let type of types) {\n      if (this.check(type)) {\n        this.advance()\n        return true\n      }\n    }\n\n    return false\n  }\n\n  private check(type: TokenType): boolean {\n    return !this.isAtEnd() && this.peek().type === type\n  }\n\n  private advance(): Token {\n    if (!this.isAtEnd()) {\n      this.current += 1\n    }\n\n    return this.previous()\n  }\n\n  private peek(): Token {\n    return this.tokens[this.current]\n  }\n\n  private previous(): Token {\n    return this.tokens[this.current - 1]\n  }\n\n  private isAtEnd(): boolean {\n    return this.peek().type === TokenType.EOF\n  }\n}\n\nenum ContextType {\n  LOOP_BODY\n}\n\nexport class Context {\n  private map: Map<ContextType, boolean[]> = new Map()\n\n  push(type: ContextType): void {\n    const ctx = this.map.get(type)\n\n    if (ctx) {\n      ctx.push(true)\n    } else {\n      this.map.set(type, [true])\n    }\n  }\n\n  pop(type: ContextType): void {\n    const ctx = this.map.get(type)\n\n    if (!ctx) {\n      throw new Error(\"Context was not entered\")\n    }\n\n    ctx.pop()\n  }\n\n  check(type: ContextType): boolean {\n    const ctx = this.map.get(type)\n\n    return !!ctx && ctx.length > 0\n  }\n}\n"]},"metadata":{},"sourceType":"module"}