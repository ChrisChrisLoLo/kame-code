{"ast":null,"code":"// import * as fs from \"fs\"\n// import * as readline from \"readline\"\nimport { Scanner } from \"./scanner\";\nimport { Parser } from \"./parser\";\nimport { Interpreter } from \"./interpreter\";\nimport { Resolver } from \"./resolver\";\nimport { AstPrinter } from \"./ast-printer\";\nexport function runInterpreter(source, options = {\n  printTokens: false,\n  printAst: false\n}) {\n  run(source, undefined, ({\n    statements,\n    tokens\n  }) => {\n    if (options.printTokens && tokens) {\n      console.log(tokens);\n    }\n\n    if (options.printAst && statements) {\n      console.log(AstPrinter.print(statements));\n    }\n  });\n} // export function main(args: string[]): void {\n//   const filePath = args[2]\n//   const debug = args[3]\n//   if (!filePath) {\n//     return runPrompt()\n//   }\n//   runFile(filePath, {\n//     printAst: !!debug && debug.includes(\"ast\"),\n//     printTokens: !!debug && debug.includes(\"tokens\")\n//   })\n// }\n// function runFile(\n//   filePath: string,\n//   options: { printTokens: boolean; printAst: boolean } = {\n//     printTokens: false,\n//     printAst: false\n//   }\n// ): void {\n//   fs.readFile(filePath, \"utf8\", (error, source) => {\n//     if (error) {\n//       console.error(error)\n//       process.exit(1)\n//     }\n//     process.exit(\n//       run(source, undefined, ({ statements, tokens }) => {\n//         if (options.printTokens && tokens) {\n//           console.log(tokens)\n//         }\n//         if (options.printAst && statements) {\n//           console.log(AstPrinter.print(statements))\n//         }\n//       })\n//     )\n//   })\n// }\n// function runPrompt(): void {\n//   const rl = readline.createInterface({\n//     input: process.stdin,\n//     output: process.stdout,\n//     prompt: \">\"\n//   })\n//   const interpreter = new Interpreter()\n//   rl.prompt()\n//   rl.on(\"line\", line => {\n//     run(line.trim(), { interpreter }, ({ result, statements }) => {\n//       if (statements) {\n//         console.log(statements)\n//         console.log(AstPrinter.print(statements))\n//       }\n//       if (result !== undefined) {\n//         console.log(stringify(result))\n//       }\n//     })\n//     rl.prompt()\n//   }).on(\"close\", () => {\n//     process.exit(0)\n//   })\n// }\n\nvar ExitCode;\n\n(function (ExitCode) {\n  ExitCode[ExitCode[\"Ok\"] = 0] = \"Ok\";\n  ExitCode[ExitCode[\"FormatError\"] = 65] = \"FormatError\";\n  ExitCode[ExitCode[\"RuntimeError\"] = 70] = \"RuntimeError\";\n})(ExitCode || (ExitCode = {}));\n\nfunction run(source, ctx = {\n  interpreter: new Interpreter()\n}, callback = () => {}) {\n  return Scanner.scan(source).match({\n    ok: tokens => {\n      callback({\n        tokens\n      });\n      return Parser.parse(tokens).match({\n        ok: statements => {\n          callback({\n            statements\n          });\n          return Resolver.resolve({\n            interpreter: ctx.interpreter,\n            statements\n          }).match({\n            ok: () => {\n              return ctx.interpreter.interpret(statements).match({\n                ok: result => {\n                  callback({\n                    result\n                  });\n                  return ExitCode.Ok;\n                },\n                fail: error => {\n                  report(error.token.line, `at \"${error.token.lexeme}\"`, error.message);\n                  return ExitCode.RuntimeError;\n                }\n              });\n            },\n            fail: errors => {\n              errors.forEach(({\n                token,\n                message\n              }) => report(token.line, `at \"${token.lexeme}\"`, message));\n              return ExitCode.FormatError;\n            }\n          });\n        },\n        fail: errors => {\n          errors.forEach(({\n            token,\n            message\n          }) => report(token.line, `at \"${token.lexeme}\"`, message));\n          return ExitCode.FormatError;\n        }\n      });\n    },\n    fail: errors => {\n      errors.forEach(({\n        line,\n        message\n      }) => report(line, \"\", message));\n      return ExitCode.FormatError;\n    }\n  });\n}\n\nfunction report(line, where, message) {\n  console.error(`[line ${line}] Error ${where}: ${message}`);\n}","map":{"version":3,"sources":["/home/chriz/Documents/kame-code/src/logic/tslox/lox.ts"],"names":["Scanner","Parser","Interpreter","Resolver","AstPrinter","runInterpreter","source","options","printTokens","printAst","run","undefined","statements","tokens","console","log","print","ExitCode","ctx","interpreter","callback","scan","match","ok","parse","resolve","interpret","result","Ok","fail","error","report","token","line","lexeme","message","RuntimeError","errors","forEach","FormatError","where"],"mappings":"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","sourcesContent":["// import * as fs from \"fs\"\n// import * as readline from \"readline\"\n\nimport { Scanner } from \"./scanner\"\nimport { Parser } from \"./parser\"\nimport { Interpreter, stringify, LoxValue } from \"./interpreter\"\nimport { Resolver } from \"./resolver\"\nimport { AstPrinter } from \"./ast-printer\"\nimport { Token } from \"./token\"\nimport * as Stmt from \"./stmt\"\n\nexport function runInterpreter(\n  source: string,\n  options: { printTokens: boolean; printAst: boolean } = {\n    printTokens: false,\n    printAst: false\n  }\n): void {\n  run(source, undefined, ({ statements, tokens }) => {\n    if (options.printTokens && tokens) {\n      console.log(tokens)\n    }\n\n    if (options.printAst && statements) {\n      console.log(AstPrinter.print(statements))\n    }\n  })\n}\n\n\n// export function main(args: string[]): void {\n//   const filePath = args[2]\n//   const debug = args[3]\n\n//   if (!filePath) {\n//     return runPrompt()\n//   }\n\n//   runFile(filePath, {\n//     printAst: !!debug && debug.includes(\"ast\"),\n//     printTokens: !!debug && debug.includes(\"tokens\")\n//   })\n// }\n\n// function runFile(\n//   filePath: string,\n//   options: { printTokens: boolean; printAst: boolean } = {\n//     printTokens: false,\n//     printAst: false\n//   }\n// ): void {\n//   fs.readFile(filePath, \"utf8\", (error, source) => {\n//     if (error) {\n//       console.error(error)\n//       process.exit(1)\n//     }\n\n//     process.exit(\n//       run(source, undefined, ({ statements, tokens }) => {\n//         if (options.printTokens && tokens) {\n//           console.log(tokens)\n//         }\n\n//         if (options.printAst && statements) {\n//           console.log(AstPrinter.print(statements))\n//         }\n//       })\n//     )\n//   })\n// }\n\n// function runPrompt(): void {\n//   const rl = readline.createInterface({\n//     input: process.stdin,\n//     output: process.stdout,\n//     prompt: \">\"\n//   })\n\n//   const interpreter = new Interpreter()\n\n//   rl.prompt()\n\n//   rl.on(\"line\", line => {\n//     run(line.trim(), { interpreter }, ({ result, statements }) => {\n//       if (statements) {\n//         console.log(statements)\n//         console.log(AstPrinter.print(statements))\n//       }\n\n//       if (result !== undefined) {\n//         console.log(stringify(result))\n//       }\n//     })\n\n//     rl.prompt()\n//   }).on(\"close\", () => {\n//     process.exit(0)\n//   })\n// }\n\nenum ExitCode {\n  Ok = 0,\n  FormatError = 65,\n  RuntimeError = 70\n}\n\nfunction run(\n  source: string,\n  ctx: { interpreter: Interpreter } = { interpreter: new Interpreter() },\n  callback: (arg: {\n    tokens?: Token[]\n    statements?: Stmt.Stmt[]\n    result?: LoxValue\n  }) => void = () => {}\n): ExitCode {\n  return Scanner.scan(source).match({\n    ok: tokens => {\n      callback({ tokens })\n\n      return Parser.parse(tokens).match({\n        ok: statements => {\n          callback({ statements })\n\n          return Resolver.resolve({\n            interpreter: ctx.interpreter,\n            statements\n          }).match({\n            ok: () => {\n              return ctx.interpreter.interpret(statements).match({\n                ok: result => {\n                  callback({ result })\n\n                  return ExitCode.Ok\n                },\n                fail: error => {\n                  report(\n                    error.token.line,\n                    `at \"${error.token.lexeme}\"`,\n                    error.message\n                  )\n                  return ExitCode.RuntimeError\n                }\n              })\n            },\n            fail: errors => {\n              errors.forEach(({ token, message }) =>\n                report(token.line, `at \"${token.lexeme}\"`, message)\n              )\n              return ExitCode.FormatError\n            }\n          })\n        },\n        fail: errors => {\n          errors.forEach(({ token, message }) =>\n            report(token.line, `at \"${token.lexeme}\"`, message)\n          )\n          return ExitCode.FormatError\n        }\n      })\n    },\n    fail: errors => {\n      errors.forEach(({ line, message }) => report(line, \"\", message))\n      return ExitCode.FormatError\n    }\n  })\n}\n\nfunction report(line: number, where: string, message: string): void {\n  console.error(`[line ${line}] Error ${where}: ${message}`)\n}\n"]},"metadata":{},"sourceType":"module"}