{"ast":null,"code":"import { RuntimeError } from \"./interpreter\";\nimport { Token } from \"./token\";\nexport class Environment {\n  constructor(enclosing) {\n    this.enclosing = enclosing;\n    this.values = new Map();\n  }\n\n  define(name, value) {\n    this.values.set(name instanceof Token ? name.lexeme : name, value);\n  }\n\n  assign(name, value) {\n    if (this.values.has(name.lexeme)) {\n      this.values.set(name.lexeme, value);\n      return;\n    }\n\n    if (this.enclosing) {\n      return this.enclosing.assign(name, value);\n    }\n\n    return this.undefinedVariableError(name);\n  }\n\n  assignAt(distance, name, value) {\n    this.ancestor(distance).values.set(name.lexeme, value);\n  }\n\n  get(name) {\n    const value = this.values.get(name.lexeme);\n\n    if (value !== undefined) {\n      return value;\n    }\n\n    if (this.enclosing) {\n      return this.enclosing.get(name);\n    }\n\n    return this.undefinedVariableError(name);\n  }\n\n  getAt(distance, name) {\n    return this.ancestor(distance).values.get(name.lexeme);\n  }\n\n  ancestor(distance) {\n    let environment = this;\n\n    for (let i = 0; i < distance; i += 1) {\n      if (!environment.enclosing) {\n        throw new Error();\n      }\n\n      environment = environment.enclosing;\n    }\n\n    return environment;\n  }\n\n  undefinedVariableError(name) {\n    throw new RuntimeError(name, `Variable ${name.lexeme} is undefined`);\n  }\n\n}","map":{"version":3,"sources":["/home/chriz/Documents/kame-code/src/logic/tslox/environment.ts"],"names":["RuntimeError","Token","Environment","constructor","enclosing","values","Map","define","name","value","set","lexeme","assign","has","undefinedVariableError","assignAt","distance","ancestor","get","undefined","getAt","environment","i","Error"],"mappings":"AAAA,SAAmBA,YAAnB,QAAuC,eAAvC;AACA,SAASC,KAAT,QAAsB,SAAtB;AAEA,OAAO,MAAMC,WAAN,CAAkB;AAGvBC,EAAAA,WAAW,CAAkBC,SAAlB,EAA2C;AAAA,SAAzBA,SAAyB,GAAzBA,SAAyB;AAAA,SAFrCC,MAEqC,GAF5B,IAAIC,GAAJ,EAE4B;AAAE;;AAExDC,EAAAA,MAAM,CAACC,IAAD,EAAuBC,KAAvB,EAA8C;AAClD,SAAKJ,MAAL,CAAYK,GAAZ,CAAgBF,IAAI,YAAYP,KAAhB,GAAwBO,IAAI,CAACG,MAA7B,GAAsCH,IAAtD,EAA4DC,KAA5D;AACD;;AAEDG,EAAAA,MAAM,CAACJ,IAAD,EAAcC,KAAd,EAAqC;AACzC,QAAI,KAAKJ,MAAL,CAAYQ,GAAZ,CAAgBL,IAAI,CAACG,MAArB,CAAJ,EAAkC;AAChC,WAAKN,MAAL,CAAYK,GAAZ,CAAgBF,IAAI,CAACG,MAArB,EAA6BF,KAA7B;AACA;AACD;;AAED,QAAI,KAAKL,SAAT,EAAoB;AAClB,aAAO,KAAKA,SAAL,CAAeQ,MAAf,CAAsBJ,IAAtB,EAA4BC,KAA5B,CAAP;AACD;;AAED,WAAO,KAAKK,sBAAL,CAA4BN,IAA5B,CAAP;AACD;;AAEDO,EAAAA,QAAQ,CAACC,QAAD,EAAmBR,IAAnB,EAAgCC,KAAhC,EAAuD;AAC7D,SAAKQ,QAAL,CAAcD,QAAd,EAAwBX,MAAxB,CAA+BK,GAA/B,CAAmCF,IAAI,CAACG,MAAxC,EAAgDF,KAAhD;AACD;;AAEDS,EAAAA,GAAG,CAACV,IAAD,EAAwB;AACzB,UAAMC,KAAK,GAAG,KAAKJ,MAAL,CAAYa,GAAZ,CAAgBV,IAAI,CAACG,MAArB,CAAd;;AAEA,QAAIF,KAAK,KAAKU,SAAd,EAAyB;AACvB,aAAOV,KAAP;AACD;;AAED,QAAI,KAAKL,SAAT,EAAoB;AAClB,aAAO,KAAKA,SAAL,CAAec,GAAf,CAAmBV,IAAnB,CAAP;AACD;;AAED,WAAO,KAAKM,sBAAL,CAA4BN,IAA5B,CAAP;AACD;;AAEDY,EAAAA,KAAK,CAACJ,QAAD,EAAmBR,IAAnB,EAA0C;AAC7C,WAAO,KAAKS,QAAL,CAAcD,QAAd,EAAwBX,MAAxB,CAA+Ba,GAA/B,CAAmCV,IAAI,CAACG,MAAxC,CAAP;AACD;;AAEOM,EAAAA,QAAR,CAAiBD,QAAjB,EAAgD;AAC9C,QAAIK,WAAwB,GAAG,IAA/B;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,QAApB,EAA8BM,CAAC,IAAI,CAAnC,EAAsC;AACpC,UAAI,CAACD,WAAW,CAACjB,SAAjB,EAA4B;AAC1B,cAAM,IAAImB,KAAJ,EAAN;AACD;;AAEDF,MAAAA,WAAW,GAAGA,WAAW,CAACjB,SAA1B;AACD;;AAED,WAAOiB,WAAP;AACD;;AAEOP,EAAAA,sBAAR,CAA+BN,IAA/B,EAAmD;AACjD,UAAM,IAAIR,YAAJ,CAAiBQ,IAAjB,EAAwB,YAAWA,IAAI,CAACG,MAAO,eAA/C,CAAN;AACD;;AA5DsB","sourcesContent":["import { LoxValue, RuntimeError } from \"./interpreter\"\nimport { Token } from \"./token\"\n\nexport class Environment {\n  private readonly values = new Map<string, LoxValue>()\n\n  constructor(private readonly enclosing?: Environment) {}\n\n  define(name: Token | string, value: LoxValue): void {\n    this.values.set(name instanceof Token ? name.lexeme : name, value)\n  }\n\n  assign(name: Token, value: LoxValue): void {\n    if (this.values.has(name.lexeme)) {\n      this.values.set(name.lexeme, value)\n      return\n    }\n\n    if (this.enclosing) {\n      return this.enclosing.assign(name, value)\n    }\n\n    return this.undefinedVariableError(name)\n  }\n\n  assignAt(distance: number, name: Token, value: LoxValue): void {\n    this.ancestor(distance).values.set(name.lexeme, value)\n  }\n\n  get(name: Token): LoxValue {\n    const value = this.values.get(name.lexeme)\n\n    if (value !== undefined) {\n      return value\n    }\n\n    if (this.enclosing) {\n      return this.enclosing.get(name)\n    }\n\n    return this.undefinedVariableError(name)\n  }\n\n  getAt(distance: number, name: Token): LoxValue {\n    return this.ancestor(distance).values.get(name.lexeme)!\n  }\n\n  private ancestor(distance: number): Environment {\n    let environment: Environment = this\n\n    for (let i = 0; i < distance; i += 1) {\n      if (!environment.enclosing) {\n        throw new Error()\n      }\n\n      environment = environment.enclosing\n    }\n\n    return environment\n  }\n\n  private undefinedVariableError(name: Token): never {\n    throw new RuntimeError(name, `Variable ${name.lexeme} is undefined`)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}